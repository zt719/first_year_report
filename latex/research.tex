\chapter{Conducted Research}

\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--guardedness}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Base}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₂}\<%
\\
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

In this section, we begin by reviewing related literature. We then introduce a categorical semantics of types, containers, W and M types. To facilitate later definition and result of higher containers in the research outcomes section, we also present related topics including categories with families, and normalization by hereditary substitutions. Finally, we outline the current challenges in this area.

\section{Literature Review}
TODO

\section{Types as Algebras}

\subsection{Inductive Types as Initial Algebras}

\subsubsection*{Natural Number}

Natural number \texttt{ℕ = \{0, 1, 2, 3, ...\}} can be defined inductively:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\end{code}

\subsubsection*{Categories of Algebras}

Given an endofunctor \texttt{F : Type → Type}, an algebra is defined as a carrier type \texttt{A : Type} and an evaluation function \texttt{α : F A → A}. The morphisms between algebras \texttt{(A ,  α)} and \texttt{(B , β)} are given by a function \texttt{f : A → B} such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  \texttt{F A} \arrow[r, "\texttt{F f}"] \arrow[d, "\texttt{α}"]
  & \texttt{F B} \arrow[d, "\texttt{β}"] \\
  \texttt{A} \arrow[r, "\texttt{f}"]
  & \texttt{B}
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the maybe functor. We write this as

\[ \texttt{ℕ ≅ μ X. ⊤ ⊎ X} \]

To prove this, we first massage its constructors into an equivalent function form:

\begin{code}%
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding function:

\begin{code}%
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{⊤ ⊎ ℕ} \arrow[r, "\texttt{⊤ ⊎ (fold α)}"] \arrow[d, "\texttt{[z,s]}"]
& \texttt{⊤ ⊎ X} \arrow[d, "\texttt{α}"] \\
\texttt{ℕ} \arrow[r, "\texttt{fold α}"]
& \texttt{X}
\end{tikzcd}
\]

\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. We dualize above diagram, defining conatural number as coinductive type and the inverse of folding function, the unfolding:

\subsubsection*{Conatural Number}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{ℕ∞}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSymbol{)}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{X} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{ℕ∞} \arrow[d, "\texttt{pred∞}"] \\
\texttt{⊤ ⊎ X} \arrow[r, "\texttt{⊤ ⊎ (unfold α⁻)}"]
& \texttt{⊤ ⊎ ℕ∞}
\end{tikzcd}
\]

Therefore conatural number is the terminal coalgebra of the same signature functor.

\[ \texttt{ℕ∞ ≅ ν X. ⊤ ⊎ X} \]

\section{Containers}

\subsection{Strict Positivity}

Containers\cite{ABBOTT20053} are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{NO\AgdaUnderscore{}POSITIVITY\AgdaUnderscore{}CHECK}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Weird}\<%
\end{code}

The type \texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Violating strict positivity can lead to issues such as non-normalizability, non-termination, inconsistency and so on. In this weird case, it becomes possible to construct a empty type term, which contradicts to the empty definition:

\begin{code}%
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSymbol{)}\<%
\end{code}

\subsection{Syntax and Semantics}

An unary container is given by a type of shapes \texttt{S} and a type family indexed by \texttt{S},called positions \texttt{P}:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
%
\>[4]\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\end{code}

Containers could be used to describe generic type (or generic class). For example, the container form of list:

\begin{code}[hide]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}

\begin{code}%
\>[0]\AgdaFunction{ListC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ListC}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaDatatype{Fin}\<%
\end{code}

The morphisms of unary containers are defined as a function which maps shapes and a family of (backward) functions that map positions indexed by \texttt{S}.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{T}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{Q}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\<%
\\
%
\>[4]\AgdaField{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{fg}\AgdaSpace{}%
\AgdaGeneralizable{hk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\<%
\end{code}

such that the identity morphisms \texttt{idContHom} and compositions \texttt{\_∘ContHom\_} exist.

\begin{code}%
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{SP}\<%
\\
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{id}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘ContHom\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{CV}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘ContHom}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\<%
\end{code}

Therefore, the containers form a category \textbf{Cont}.

\begin{code}%
\>[0]\AgdaFunction{tailC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaFunction{ListC}\AgdaSpace{}%
\AgdaFunction{ListC}\<%
\\
\>[0]\AgdaFunction{tailC}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{g}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
%
\>[2]\AgdaFunction{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaFunction{f}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
%
\>[2]\AgdaFunction{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{f}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[2]\AgdaFunction{g}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\>[2]\AgdaFunction{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

\subsubsection*{Extension Functor}

An unary container gives rise to a endofunctor of \texttt{Set} along the container extension functor \texttt{⟦\_⟧}. We explicitly distinguish mapping objects and mapping morphisms part of a functor.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦\AgdaUnderscore{}⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\<%
\\
%
\>[4]\AgdaField{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧₁}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧₁}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{k}\<%
\end{code}

As containers give rise to functors, naturally, the morphisms of containers give rise to the morphisms of functors - the natural transformations:

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧Hom}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧Hom}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

We show that the extension functor is fully faithful by constructing a bijection between \texttt{ContHom (S ◃ P) (T ◃ Q)} and \texttt{NatTrans ⟦ S ◃ P ⟧ ⟦ T ◃ Q ⟧}

\begin{align*}
& S \triangleleft P \rightarrow_{Cont} T \triangleleft Q \\
&= \sum_{f : S \rightarrow T} \prod_{s : S} Q \; (f \; s) \rightarrow P \; s && \text{definition of $\rightarrow_{Cont}$} \\
&\cong \prod_{s : S} \sum_{t : T} Q \; t \rightarrow P \; s && \text{type theoretical choice} \\
&= \prod_{s : S} \llbracket T \triangleleft Q \rrbracket (P \; s) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \prod_{s : S} \int_{X : Set} ((P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{covariant Yoneda lemma} \\
&\cong \int_{X : Set} \prod_{s : S} ((P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{commutative of $\int$ and $\prod$} \\
&\cong \int_{X : Set} (\sum_{s : S} (P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{uncurry} \\
&= \int_{X : Set} \llbracket S \triangleleft P \rrbracket X \rightarrow \llbracket T \triangleleft Q \rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, zero, multiplication and addition for containers:

\begin{code}%
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{const}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

such that the semiring laws should hold. Both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. We use \texttt{⊥}, \texttt{⊤}, \texttt{×} and \texttt{⊎} as they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers. In fact, the category of containers has all finite products and coproducts. We give the definitions and show that they are both preserved by the extension functor.

\subsubsection*{Products}

\begin{code}%
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \prod_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \prod_{i : I} \sum_{s : S_i} (P_i \; s \rightarrow X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{f : \prod_{i : I} S_i} \prod_{i : I} (P_i \; (f \; i) \rightarrow X) && \text{type theoretical choice} \\
&\cong \sum_{f : \prod_{i : I} S_i} \left( \sum_{i : I} P_i \; (f \; i) \rightarrow X \right) && \text{uncurry} \\
&= \left\llbracket f : \prod_{i : I} S_i \triangleleft \sum_{i : I} P_i \; (f \; i) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Coproducts}

\begin{code}%
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{align*}
& \sum_{i : I} ( \llbracket S_i \triangleleft P_i \rrbracket X ) \\
&= \sum_{i : I} \sum_{s : S_i} ( P_i \; s \rightarrow X ) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{(i , s_i) : \sum_{i : I} S_i} ( P_i \; s_i \rightarrow X ) && \text{associative of $\sum$} \\
&= \left\llbracket (i , s_i) : \sum_{i : I} S_i \triangleleft P_i \; s_i \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Composition}

We can also define composition of unary containers.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{S}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \llbracket S \triangleleft P \rrbracket (\llbracket T \triangleleft Q \rrbracket X) \\
&= \sum_{s : S} \left( P \; s \rightarrow \sum_{t : T} (Q \; t \rightarrow X) \right) && \text{ definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{s : S} \sum_{f : P \: s \rightarrow T} \prod_{p : P \: s} (Q \; (f \; p) \rightarrow X) && \text{type theoretical choice} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \prod_{p : P \: s} (Q \; (f \; p) \rightarrow X) && \text{associative of $\sum$} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \left( \sum_{p : P \: s} Q \; (f \; p) \rightarrow X \right) && \text{uncurry} \\
&= \left\llbracket \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \triangleleft \sum_{p : P \: s} Q \; (f \; p) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{2-Categorical Structures}

\textbf{Cont} has 2-categorical structures as the extension functor leads to the functor category. The vertical composition is just \texttt{\_∘ContHom\_}. We define the horizontal compositions (tensor products) of morphisms, which also corresponds to the functoriality of \texttt{\_∘C\_}

\subsubsection*{Horizontal Compositions}

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊗ContHom\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ContHom}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g'}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{q'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

such that the identity and compositions (interchanged law) are preserved. The proof is immediate by checking cases.

TODO : I need a diagram here

\subsection{W and M}

We now present the general form of inductive types, which is the W type:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{sup}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\<%
\end{code}

This definition implies that any inductive type can be characterized by a container algebra. Indeed, we can retrieve an equivalent definition of natural number through the maybe container.

\begin{code}%
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Dually, the general form of coinductive types - M type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{inf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{M}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{M}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{⟦ SP ⟧ }\texttt{(W SP)} \arrow[r, "\texttt{⟦ SP ⟧ (fold α)}"] \arrow[d, "\texttt{sup}"]
& \texttt{⟦ SP ⟧ X} \arrow[d, "\texttt{α}"] \\
\texttt{W SP} \arrow[r, "\texttt{fold α}"]
& \texttt{X}
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{X} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{M SP} \arrow[d, "\texttt{inf}"] \\
\texttt{⟦ SP ⟧ X} \arrow[r, "\texttt{⟦ SP ⟧ (unfold α⁻)}"]
& \texttt{⟦ SP ⟧ (M SP)}
\end{tikzcd}
\]

\input{latex/scwfs}

\section{Normalization by Hereditary Substitutions}

We introduce the hereditary substitutions technique for \lambda-calculus normalization. To build the syntax of \lambda-calculus, we first define a simple syntax of types and contexts. We use \texttt{A B C} to range over types and \texttt{Γ Δ Θ} to range over contexts.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{*}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{∙}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\end{code}

\subsubsection*{De Bruijn Indices}

We adopt the De Bruijn indices to capture variables. The idea is to replace the name of variable in context with number, with the innermost (rightmost) variable gets index 0 and outermost (leftmost) variable gets the biggest index. For example \texttt{λx.λy.x} in de bruijn form is \texttt{λ.λ.1}. We use \texttt{x y} to range over variables.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\end{code}

\subsubsection*{\lambda-Terms}

The \lambda-terms follows the normal convention, which is either a variable, or a \lambda-abstraction, or a term application.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{var}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{app}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\end{code}

\subsubsection*{Normal Forms}

We also need to define the syntax of normal forms. Normalized \lambda-terms are defined as either: \lambda-abstractions of normal forms; or neutral terms, where neutral terms are variables applied to lists of normal forms, called the spines. The \texttt{Nf}, \texttt{Ne} and \texttt{Sp} are mutually defined in Agda:

\begin{code}%
\>[0]\AgdaKeyword{mutual}\<%
\end{code}

\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaInductiveConstructor{ne}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{ε}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Γ}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{EqVar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{EqVar}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{x}\<%
\\
%
\>[2]\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{EqVar}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{EqVar}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{eq}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{x}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{mutual}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ns}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ns}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{appSp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
\>[0]\AgdaFunction{appSp}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{appSp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{appSp}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}

In TODO, it builds a canonical normalizer for \lambda-calculi - \texttt{nf : Tm Γ A → Nf Γ A}. We shall not go through the full normalization process in details, but just illustrating the key components for each case.

A variable is normalized by performing \eta-expansion to the fullest extent possible, defined by \texttt{nvar}. For example, a variable with type \texttt{(* ⇒ *) ⇒ * ⇒ *}:

\[ \texttt{H} \rightarrow \texttt{λF.H F} \rightarrow \texttt{λX.λF.H F X} \]

\begin{code}[hide]%
\>[0]\AgdaKeyword{mutual}\<%
\end{code}

\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{appSp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSymbol{)))}\<%
\end{code}

The application case is more involved, where it is the actual hereditary substitutions happening. The substitutions under normal forms are recursively defined together with substitutions under neutral terms and spines. Finally, the \texttt{napp} launches the whole process by substitutes the top variable of first term by the second term.

\begin{code}[hide]%
\>[0]\AgdaKeyword{mutual}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}[\AgdaUnderscore{}:=\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{eq}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{x}}\AgdaSpace{}%
\AgdaBound{y'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\AgdaUnderscore{}:=\AgdaUnderscore{}>}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}◇\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\<%
\\
%
\>[2]\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{us}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{napp}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaBound{us}\<%
\end{code}

\begin{code}%
%
\>[2]\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\end{code}

Finally, we obtain the normalization function that \beta-reduces and \eta-expands simply typed terms.

\begin{code}%
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{var}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{app}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{u}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{u}\AgdaSymbol{)}\<%
\end{code}

In TODO, it shows the completeness and soundness of the normalizer. But we omit the proof for simplicity purpose.

\section{Questions}

\subsection{Bush}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{head}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\>[4]\AgdaField{tail}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Bush}\<%
\end{code}

How do we represent \texttt{Bush X} as a M type? It turns out that previews scheme is no longer applicable. To address the issue, the key observation is to lift the space from \texttt{Set} to \texttt{Set → Set}. We can show \texttt{Bush} is the ``higher'' terminal coalgebra of a ``higher'' endofunctor:

\begin{code}%
\>[0]\AgdaFunction{H}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{H}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\<%
\end{code}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{F} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{Bush} \arrow[d, "\texttt{< head , tail >}"] \\
\texttt{H F} \arrow[r, "\texttt{H (unfold α⁻)}"]
& \texttt{H Bush}
\end{tikzcd}
\]