\chapter{Conducted Research}

\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--guardedness}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Base}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₂}\<%
\\
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

In this section, we begin by reviewing related literatures. We then introduce related research topics including the categorical semantics of types, containers, W and M types, and categories with families. Finally, we outline the current challenges in this research.

\section{Literature Review}

\subsubsection*{Denotational Semantics of Inductive Types}

From a categorical point of view, inductive types are understood as the initial algebras of functors, which the result was originally carried out in (Goguen, Thatcher, Wagner and Wright 1977)\cite{goguen1977initial}. Later, the W-type was explored by (Dybjer 1997)\cite{dybjer1997representing} as an encoding of strictly positive inductive types . It has been proved that every strictly positive endofunctor on the category of sets generated by Martin-Löf's extensional type theory has an initial algebra.

\subsubsection*{Containers}

(Abbott, Altenkirch and Ghani 2003)\cite{abbott2003categories} presented the categories of containers and showed some nice closure properties. This work could be used to redefine W-type and therefore serve as an alternative semantics of strictly positive types. Later, in (Abbott, Altenkirch and Ghani 2005)\cite{abbott2005containers}, the n-ary containers were introduced to capture data types with arguments such as lists and trees. And in (Altenkirch and Ghani 2015), the indexed containers were studied to cover inductive type families such as vectors. They also showed that indexed W-type can be converted into normal W-type. Some related formalization has been done in Cubical Agda in (Damato, Altenkirch and Ljungström 2024)\cite{damato2024formalising}.

\subsubsection*{This work}

The object of this project is to review this categorical semantics of higher-order data types. We formalize the syntax and semantics in Agda. We also ``containerize'' the definition to provide the semantics higher-order strict positivity.

\section{Categorical Semantics of Types}

In the type theory formalization, inductive types are primitive structures specified by a set of inference rules, including type formation rules, introduction rules, induction rules and elimination rules\cite{rijke2022introduction}. For instance, in Agda the type of natural numbers is define as:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\end{code}

Categorical semantics provides a deeper, structural interpretation of this idea by modeling inductive types as the initial algebras of a functor.

\subsection{Inductive Types as Initial Algebras}

\subsubsection*{Categories of Algebras}

Given an endofunctor $F : \textbf{Set} \to \textbf{Set}$, an algebra is defined as a carrier type $A : Set$ and an evaluation function $\alpha : F(A) \to A$. The morphisms between algebras $(A,\alpha)$ and $(B,\beta)$ are given by a function $f : A \to B$ such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  F\;A \arrow[r, "F\;f"] \arrow[d, "\alpha"]
  & F\;B \arrow[d, "\beta"] \\
  A \arrow[r, "f"]
  & B
\end{tikzcd}
\]

$\mathbb{N}$ (with its constructors) is the initial algebra of the maybe functor. We write this as $\mathbb{N} \cong \mu X. 1 + X$. To prove this result, we first massage its constructors into a function form:

\begin{code}%
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding function:

\begin{code}%
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5cm]
1 + \mathbb{N} \arrow[r, "1 + fold(\alpha)"] \arrow[d, "{[z,s]}"]
& 1 + X \arrow[d, "\alpha"] \\
\mathbb{N} \arrow[r, "fold(\alpha)"]
& X
\end{tikzcd}
\]

\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. The dual notion of natural number is call the conatural number. By duality, conatural number is the terminal coalgebra of $Maybe$ functor, we write this as $\mathbb{N}\infty \cong \nu X. 1 + X$. In Agda, conatural number is defined as a coinductive type:

\subsubsection*{Conatural Number}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{ℕ∞}\<%
\end{code}

To complete the diagram, we also define the inverse of folding, which is called unfolding:

\begin{code}%
\>[0]\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSymbol{)}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold(\alpha^{-})"] \arrow[d, "\alpha^{-}"]
& \mathbb{N}\infty \arrow[d, "pred\infty"] \\
1 + X \arrow[r, "1 + unfold(\alpha^{-})"]
& 1 + \mathbb{N}\infty
\end{tikzcd}
\]

\section{Containers}

\subsection{Strict Positivity}

Containers are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{NO\AgdaUnderscore{}POSITIVITY\AgdaUnderscore{}CHECK}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Weird}\<%
\end{code}

The type \texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Violating strict positivity can lead to issues such as non-normalizability, non-termination, inconsistency and so on. In this weird case, it becomes possible to construct a empty type term, which contradicts to the empty definition:

\begin{code}%
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSymbol{)}\<%
\end{code}

\subsection{Syntax and Semantics}

An unary container is given by a type of shapes \textit{S} and a type family indexed by \textit{S},called positions \textit{P}:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
%
\>[4]\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\end{code}

The morphisms of unary containers are defined as a function which maps shapes and a family of (backward) functions that map positions indexed by shapes.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{T}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{Q}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\<%
\\
%
\>[4]\AgdaField{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{fg}\AgdaSpace{}%
\AgdaGeneralizable{hk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\<%
\end{code}

such that the identity morphisms and compositions exist.

\begin{code}%
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{SP}\<%
\\
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{id}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘ContHom\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{CV}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘ContHom}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\<%
\end{code}

Therefore, they form a category \textbf{CONT}.

\subsubsection*{Extension Functor}

An unary container gives rise to a functor $\textbf{Set} \to \textbf{Set}$ along the container extension functor $\llbracket\_\rrbracket$. We denote the mapping objects of a functor with no subscript or $_0$ as it maps 0-cell, and mapping morphisms part with $_1$ as it maps 1-cell.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦\AgdaUnderscore{}⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\<%
\\
%
\>[4]\AgdaField{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧₁}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧₁}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{k}\<%
\end{code}

As containers give rise to functors, the morphisms of containers naturally give rise to the morphisms of functors - the natural transformations:

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧Hom}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧Hom}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

We show that the extension functor is fully faithful by constructing a bijection between $S \triangleleft P \to T \triangleleft Q$ and $\llbracket S \triangleleft P \rrbracket \to \llbracket T \triangleleft Q \rrbracket$

\begin{align*}
& S \triangleleft P \rightarrow_{Cont} T \triangleleft Q \\
&= \sum_{f : S \to T} \prod_{s : S} Q \; (f \; s) \to P \; s && \text{definition of $\rightarrow_{Cont}$} \\
&\cong \prod_{s : S} \sum_{t : T} Q \; t \to P \; s && \text{type theoretical choice} \\
&= \prod_{s : S} \llbracket T \triangleleft Q \rrbracket (P \; s) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \prod_{s : S} \int_{X : Set} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{covariant Yoneda lemma} \\
&\cong \int_{X : Set} \prod_{s : S} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{commutative of $\int$ and $\prod$} \\
&\cong \int_{X : Set} (\sum_{s : S} (P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{uncurry} \\
&= \int_{X : Set} \llbracket S \triangleleft P \rrbracket X \to \llbracket T \triangleleft Q \rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, zero, multiplication and addition for containers:

\begin{code}%
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{const}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

such that the semiring laws should hold. Both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. We use \texttt{⊥}, \texttt{⊤}, \texttt{×} and \texttt{⊎} as they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers. In fact, the category of containers has all finite products and coproducts. We give the definitions and show that they are both preserved by the extension functor.

\subsubsection*{Products}

\begin{code}%
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \prod_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \prod_{i : I} \sum_{s : S_i} (P_i \; s \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{f : \prod_{i : I} S_i} \prod_{i : I} (P_i \; (f \; i) \to X) && \text{type theoretical choice} \\
&\cong \sum_{f : \prod_{i : I} S_i} \left( \sum_{i : I} P_i \; (f \; i) \to X \right) && \text{uncurry} \\
&= \left\llbracket f : \prod_{i : I} S_i \triangleleft \sum_{i : I} P_i \; (f \; i) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Coproducts}

\begin{code}%
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{align*}
& \sum_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \sum_{i : I} \sum_{s_i : S_i} (P_i \; s_i \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{(i , s_i) : \sum_{i : I} S_i} (P_i \; s_i \to X) && \text{associative of $\sum$} \\
&= \left\llbracket (i , s_i) : \sum_{i : I} S_i \triangleleft P_i \; s_i \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Compositions}

We can also define compositions of unary containers. This composition should reflect the process of consecutively applying container functors.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{S}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \llbracket S \triangleleft P \rrbracket (\llbracket T \triangleleft Q \rrbracket X) \\
&= \sum_{s : S} \left( P \; s \to \sum_{t : T} (Q \; t \to X) \right) && \text{ definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{s : S} \sum_{f : P \: s \to T} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{type theoretical choice} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{associative of $\sum$} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \left( \sum_{p : P \: s} Q \; (f \; p) \to X \right) && \text{uncurry} \\
&= \left\llbracket \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \triangleleft \sum_{p : P \: s} Q \; (f \; p) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{W and M}

We now present the general form of inductive types, which is the W-type. The standard notion in the HoTT book is given by $A : Type$ and $B : A \to Type$, which is written as $W_{a : A} B (a)$. It is equipped with a single constructor $sup : \prod_{a : A} (B (a) \to W_{x : A} B (x)) \to W_{x : A} B (x)$. Notice that this definition is equivalent to the following container definition:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{sup}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\<%
\end{code}

This definition implies that any inductive type can be characterized by a container functor algebra. Indeed, we can retrieve an equivalent definition of natural number through the maybe container.

\begin{code}%
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Dually, the general form of coinductive types - M-type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{inf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{M}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{M}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\llbracket SP \rrbracket (W(SP)) \arrow[r, "\llbracket SP \rrbracket (fold(\alpha))"] \arrow[d, "sup"]
& \llbracket SP \rrbracket X \arrow[d, "\alpha"] \\
W(SP) \arrow[r, "fold(\alpha)"]
& X
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold(\alpha^{-})"] \arrow[d, "\alpha^{-}"]
& M(SP) \arrow[d, "inf"] \\
\llbracket SP \rrbracket X \arrow[r, "\llbracket SP \rrbracket (unfold(\alpha^{-}))"]
& \llbracket SP \rrbracket (M(SP))
\end{tikzcd}
\]

As a conclusion, W and M are essentially \mu and \nu:

\[ W(S \triangleleft P) \cong \mu X. \llbracket S \triangleleft P \rrbracket X \]
\[ M(S \triangleleft P) \cong \nu X. \llbracket S \triangleleft P \rrbracket X \]

\section{Categories with Families}

The Categories with Families (CwFs) are categorical framework for interpreting dependent type theory. They model core concepts like context formation, substitution, weakening, etc. However, CwFs are more related to an alternative type theory - a substitution calculus by Martin-Löf, in which the substitution is first class and explicitly formulated.

\subsection{General Definition}

There are many equivalent ways to define CwFs, we only present one definition which is suitable for our formalization. A CwF is given by:

\begin{itemize}
  \item{A category \textbf{C}. Its objects is a set of contexts, denoted by $\Gamma$, $\Delta$, etc, Its morphisms is a set of context substitutions, denoted by $\gamma$, $\delta$, etc. We call the objects type $Con$ and morphisms type $Tms$ (or $Subst$).
  
  Categorical rules for \textbf{C}:

  \begin{align*}
    id_{\Gamma} \circ \gamma & = \gamma \\
    \gamma \circ id_{\Gamma} & = \gamma \\
    (\gamma \circ \delta) \circ \theta & = \gamma \circ (\delta \circ \theta) \\
  \end{align*}
  }

  \item{A terminal object $\bullet : Con$ which represents the empty context, with the terminal map $\epsilon_{\Gamma} : Tms\;\Gamma\;\bullet$ which represents the empty substitution. 
  
  Universal property of $\bullet$:

  \begin{align*}
    \epsilon_{\Gamma} \circ \gamma & = \epsilon_{\Gamma} \\
    id_{\bullet} & = \epsilon_{\bullet} \\
  \end{align*}
  }

  \item{A presheaf $Ty : \textbf{C}^{op} \to \textbf{Set}$ which represents a set of types of a given context $\Gamma$. We use A, B, etc. to denote type. For each $\gamma : Tms (\Delta, \Gamma)$, we also define a special syntax $\_[\gamma] : Ty(\Gamma) \to Ty(\Delta)$ for the mapping morphisms part of $Ty$.

  Functoriality of $Ty$:

  \begin{align*}
    A [id_{\Gamma}] & = A \\
    A [\gamma \circ \delta] & = A [\gamma] [\delta] \\
  \end{align*}
  }

  \item{A presheaf 
  $Tm : (\int_{\textbf{C}})^{op} \to \textbf{Set}$ 
  which represents a set of terms of a given type $Ty(\Gamma)$. We use a, b, etc. to denote terms. For each $\gamma : Tms (\Delta, \Gamma)$ and $A : Ty(\Gamma)$, we also define a special syntax $\_[\gamma] : Tm(\Gamma, A) \to Tm(\Delta, A [\gamma])$ for the mapping morphisms part of $Tm$.

  Functoriality of $Ty$:

  \begin{align*}
    a [id_{\Gamma}] & = a \\
    a [\gamma \circ \delta] & = a [\gamma] [\delta] \\
  \end{align*}
  }

\item{A comprehension operation, which represents the context extensions. For each $\Gamma : Con$ and $A : Ty(\Gamma)$, there is an extended context $\Gamma \triangleright A$. For each $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm (\Delta, A[\gamma])$, there is an extended substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$. For each $\gamma : Tms (\Delta, \Gamma \triangleright A)$, there is a projection from $\gamma$ to $Tms (\Delta, \Gamma)$ that forgets the top variable, denoted by $\pi_1$; and a projection from $\gamma$ to an unique term $a : Tm (\Delta, A[\pi_1 \gamma])$ which essentially is the variable being forgotten, denoted by $\pi_2$.

The comprehension also comes with an universal property that, for every $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm(\Gamma , A[\gamma])$, there exists a unique substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$, such that:

  \begin{align*}
    \pi_1\;(\gamma, a) & = \gamma \\
    \pi_2\;(\gamma, a) & = a \\
    (\pi_1\;\gamma , \pi_2\;\gamma) & = \gamma \\
    (\delta, a) \circ \gamma & = (\delta \circ \gamma , a) \\
  \end{align*}
  }
  
\end{itemize}

\subsection{Adding Functions}

The CwF on its own typically does not say anything about types. We can add dependent function types to the framework separately.

For each $\Gamma : Con$, $A : Ty(\Gamma)$ and $B : Ty(\Gamma \triangleright A)$, there exist a dependent function type $\Pi (A, B) : Ty(\Gamma)$. For each $b : Tm(\Gamma \triangleright A, B)$, there is a function $lam(b) : Tm (\Gamma, \Pi (A, B))$. Inversely, for each $f : Tm(\Gamma, \Pi (A, B))$, there is a term $app(f) : Tm(\Gamma \triangleright A, B)$.

Rules for $lam$ and $app$, which are essentially \beta-rule and \eta-rule:

\begin{align*}
  app (lam (a)) & = a \\
  lam (app (f)) & = f \\
\end{align*}

In order to define the substitutions under $\Pi$, $lam$ and $app$, we need to first construct context substitution lifting operation: for each $\gamma : Tms (\Delta, \Gamma)$, it can be lifted to $\gamma \uparrow : Tms (\Delta \triangleright A [\gamma], \Gamma \triangleright A)$ by arbitrary $A : Ty(\Gamma)$.

Rules for substitution lifting and functions under substitutions.

\begin{align*}
  \gamma \uparrow & = \gamma \circ (\pi_1\;id) , \pi_2\;id \\
  (\Pi(A,B)) [\gamma] &= \Pi (A [\gamma], B [\gamma \uparrow]) \\
  (lam (a)) [\gamma] &= lam (t [\gamma \uparrow]) \\
  (app (f)) [\gamma \uparrow] &= app (f [\gamma]) \\
\end{align*}

\subsection{Simply Typed Categories with Families}

For the purposes of our research, we are primarily interested in a weaker variant of CwF, namely the simply typed CwF $(SCwF)$. The essence of a SCwF is to capture precisely the model of the simply typed \lambda-calculus, where types are independent of context. Therefore, while context substitution is still required for terms, it is not needed for types.

The model can be derived by constraining $Ty$ to be a constant presheaf. That is:

\begin{align*}
  & Ty : \textbf{C}^{op} \to \textbf{Set} \\
  & Ty(\Gamma) := STy \\
  & Ty(\gamma) := id \\
\end{align*}

where $STy$ should be a set of simple types.

\section{Questions}

\subsection{Bush}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{head}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\>[4]\AgdaField{tail}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Bush}\<%
\end{code}

How do we represent $Bush(X)$ as a M-type? It turns out that previews scheme is no longer applicable. To address the issue, the key is to lift the space from $Set$ to $Set \to Set$. We can show $Bush$ on its own is the terminal coalgebra of an endofunctor $H$ of the functor category $\textbf{[Set,Set]}$.

\begin{align*}
& H : (Set \to Set) \to Set \to Set \\
& H (F) (X) = X \times F (F (X)) \\
\end{align*}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
F \arrow[r, "unfold(\alpha^{-})"] \arrow[d, "\alpha^{-}"]
& Bush \arrow[d, "{<head,tail>}"] \\
H(F) \arrow[r, "H\;(unfold(\alpha^{-}))"]
& H(Bush)
\end{tikzcd}
\]