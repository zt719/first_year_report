\chapter{Conducted Research}

\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--guardedness}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Base}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
\>[0]\AgdaFunction{Type}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₂}\<%
\\
\>[0]\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

In this section, we begin by reviewing related literatures. We then introduce a categorical semantics of types, containers, W and M types. To facilitate later definition and result of higher containers in the research outcomes section, we also present related topics including categories with families, and normalization by hereditary substitutions. Finally, we outline the current challenges in this area.

\section{Literature Review}

\subsubsection*{Denotational Semantics of Inductive Types}

From a categorical point of view, inductive types are understood as the initial algebras of functors, which the result was carried out by (Goguen, Thatcher, Wagner and Wright 1977)\cite{goguen1977initial}. Later, the W type as an encoding of strictly positive inductive types was explored by (Dybjer 1997)\cite{dybjer1997representing}. It was proved that every strictly positive endofunctor on the category of sets generated by Martin-Löf's extensional type theory has an initial algebra.

\subsubsection*{Containers}

(Abbott, Altenkirch and Ghani 2003)\cite{abbott2003categories} presented the categories of containers and showed some nice closure properties. This work could be used to redefine W type and therefore serve as an alternative semantics of strictly positive types. Later, in (Abbott, Altenkirch and Ghani 2005)\cite{abbott2005containers}, the n-ary containers were introduced to capture data types with arguments such as lists and trees. And in (Altenkirch and Ghani 2015), the indexed containers were studied to cover inductive type families such as vectors. They also showed that indexed W type can be converted into normal W type. Some related formalization has been done in Cubical Agda in (Damato, Altenkirch and Ljungström 2024)\cite{damato2024formalising}.

\subsubsection*{Higher-Order Data Types}

In (Johann and Polonsky 2019)\cite{johann2019higher}, they presented the syntax of semantics of higher-order data types.

\subsubsection*{This work}

The object of this project is to review this categorical semantics of higher-order data types. We formalize the syntax and semantics in Agda. We also ``containerize'' the definition to provide the semantics higher-order strict positivity.

\section{Types as Algebras}

\subsection{Inductive Types as Initial Algebras}

\subsubsection*{Natural Number}

Natural number {$\mathbb{N}$ := {0, 1, 2, 3, ...} can be defined inductively:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\end{code}

\subsubsection*{Categories of Algebras}

Given an endofunctor $F : \textbf{Set} \to \textbf{Set}$, an algebra is defined as a carrier type $A : Set$ and an evaluation function $\alpha : F\;A \to A$. The morphisms between algebras $(A,\alpha)$ and $(B,\beta)$ are given by a function $f : A \to B$ such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  F\;A \arrow[r, "F\;f"] \arrow[d, "\alpha"]
  & F\;B \arrow[d, "\beta"] \\
  A \arrow[r, "f"]
  & B
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the maybe functor. We write this as $\mathbb{N} \cong \mu X. 1 + X$.

To prove this result, we first massage its constructors into an equivalent function form:

\begin{code}%
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\<%
\\
\>[0]\AgdaFunction{[z,s]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding function:

\begin{code}%
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{fold}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5cm]
1 + \mathbb{N} \arrow[r, "1 + fold\;\alpha"] \arrow[d, "{[z,s]}"]
& 1 + X \arrow[d, "\alpha"] \\
\mathbb{N} \arrow[r, "fold\;\alpha"]
& X
\end{tikzcd}
\]


\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. We therefore dualize the concept of natural number. The conatural number is the terminal coalgebra of the maybe functor, we write this as $\mathbb{N}\infty \cong \nu X. 1 + X$. In Agda, conatural number is defined as coinductive type:

\subsubsection*{Conatural Number}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{ℕ∞}\<%
\end{code}

To complete the diagram, we also define the inverse of folding, which is called unfolding:

\begin{code}%
\>[0]\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ℕ∞}\<%
\\
\>[0]\AgdaField{pred∞}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{unfold}\AgdaSpace{}%
\AgdaBound{α⁻}\AgdaSpace{}%
\AgdaBound{x'}\AgdaSymbol{)}\<%
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& \mathbb{N}\infty \arrow[d, "pred\infty"] \\
1 + X \arrow[r, "1 + unfold\;\alpha^{-}"]
& 1 + \mathbb{N}\infty
\end{tikzcd}
\]

\section{Containers}

\subsection{Strict Positivity}

Containers are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{NO\AgdaUnderscore{}POSITIVITY\AgdaUnderscore{}CHECK}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Weird}\<%
\end{code}

The type \texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Violating strict positivity can lead to issues such as non-normalizability, non-termination, inconsistency and so on. In this weird case, it becomes possible to construct a empty type term, which contradicts to the empty definition:

\begin{code}%
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Weird}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{empty}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{foo}\AgdaSpace{}%
\AgdaFunction{¬weird}\AgdaSymbol{)}\<%
\end{code}

\subsection{Syntax and Semantics}

An unary container is given by a type of shapes \textit{S} and a type family indexed by \textit{S},called positions \textit{P}:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type₁}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
%
\>[4]\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\end{code}

The morphisms of unary containers are defined as a function which maps shapes and a family of (backward) functions that map positions indexed by $S$.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}◃\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{TQ}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{S}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{T}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{P}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{Q}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\<%
\\
%
\>[4]\AgdaField{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{fg}\AgdaSpace{}%
\AgdaGeneralizable{hk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\<%
\end{code}

such that the identity morphisms and compositions exist.

\begin{code}%
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{SP}\<%
\\
\>[0]\AgdaFunction{idContHom}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{id}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘ContHom\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaGeneralizable{CV}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{CV}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘ContHom}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{h}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\<%
\end{code}

Therefore, they form a category \textbf{CONT}.

\subsubsection*{Extension Functor}

An unary container gives rise to a functor $\textbf{Set} \to \textbf{Set}$ along the container extension functor $\llbracket\_\rrbracket$. We denote the mapping objects of a functor with no subscript or $_0$ as it maps 0-cell, and mapping morphisms part with $_1$ as it maps 1-cell.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦\AgdaUnderscore{}⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cont}\AgdaSpace{}%
\AgdaBound{SP}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{S}\<%
\\
%
\>[4]\AgdaField{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{P}\AgdaSpace{}%
\AgdaField{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧₁}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧₁}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{k}\<%
\end{code}

As containers give rise to functors, the morphisms of containers naturally give rise to the morphisms of functors - the natural transformations:

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧Hom}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧Hom}}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

We show that the extension functor is fully faithful by constructing a bijection between $S \triangleleft P \to T \triangleleft Q$ and $\llbracket S \triangleleft P \rrbracket \to \llbracket T \triangleleft Q \rrbracket$

\begin{align*}
& S \triangleleft P \rightarrow_{Cont} T \triangleleft Q \\
&= \sum_{f : S \to T} \prod_{s : S} Q \; (f \; s) \to P \; s && \text{definition of $\rightarrow_{Cont}$} \\
&\cong \prod_{s : S} \sum_{t : T} Q \; t \to P \; s && \text{type theoretical choice} \\
&= \prod_{s : S} \llbracket T \triangleleft Q \rrbracket (P \; s) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \prod_{s : S} \int_{X : Set} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{covariant Yoneda lemma} \\
&\cong \int_{X : Set} \prod_{s : S} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{commutative of $\int$ and $\prod$} \\
&\cong \int_{X : Set} (\sum_{s : S} (P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{uncurry} \\
&= \int_{X : Set} \llbracket S \triangleleft P \rrbracket X \to \llbracket T \triangleleft Q \rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, vz, multiplication and addition for containers:

\begin{code}%
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{const}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊥C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

such that the semiring laws should hold. Both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. We use \texttt{⊥}, \texttt{⊤}, \texttt{×} and \texttt{⊎} as they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers. In fact, the category of containers has all finite products and coproducts. We give the definitions and show that they are both preserved by the extension functor.

\subsubsection*{Products}

\begin{code}%
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΠC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \prod_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \prod_{i : I} \sum_{s : S_i} (P_i \; s \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{f : \prod_{i : I} S_i} \prod_{i : I} (P_i \; (f \; i) \to X) && \text{type theoretical choice} \\
&\cong \sum_{f : \prod_{i : I} S_i} \left( \sum_{i : I} P_i \; (f \; i) \to X \right) && \text{uncurry} \\
&= \left\llbracket f : \prod_{i : I} S_i \triangleleft \sum_{i : I} P_i \; (f \; i) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Coproducts}

\begin{code}%
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{ΣC}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{SPs}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{.}\AgdaField{Cont.P}\AgdaSpace{}%
\AgdaBound{s}\<%
\end{code}

\begin{align*}
& \sum_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \sum_{i : I} \sum_{s_i : S_i} (P_i \; s_i \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{(i , s_i) : \sum_{i : I} S_i} (P_i \; s_i \to X) && \text{associative of $\sum$} \\
&= \left\llbracket (i , s_i) : \sum_{i : I} S_i \triangleleft P_i \; s_i \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Compositions}

We can also define compositions of unary containers. This composition should reflect the process of consecutively applying container functors.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘C\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{S}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{T}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{S}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{T}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}

\begin{align*}
& \llbracket S \triangleleft P \rrbracket (\llbracket T \triangleleft Q \rrbracket X) \\
&= \sum_{s : S} \left( P \; s \to \sum_{t : T} (Q \; t \to X) \right) && \text{ definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{s : S} \sum_{f : P \: s \to T} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{type theoretical choice} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{associative of $\sum$} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \left( \sum_{p : P \: s} Q \; (f \; p) \to X \right) && \text{uncurry} \\
&= \left\llbracket \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \triangleleft \sum_{p : P \: s} Q \; (f \; p) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{2-Categorical Structures}

\textbf{Cont} has 2-categorical structures as the extension functor leads to the functor category. The vertical composition is just \AgdaFunction{\_∘ContHom\_}. We define the horizontal compositions (tensor products) of morphisms, which also corresponds to the functoriality of \AgdaFunction{\_∘C\_}

\subsubsection*{Horizontal Compositions}

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊗ContHom\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{ContHom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaGeneralizable{SP'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{TQ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘C}}\AgdaSpace{}%
\AgdaGeneralizable{TQ'}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ContHom}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaBound{g'}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{q'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{q'}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}

such that the identity and compositions (interchanged law) are preserved. The proof is immediate by checking cases.

TODO : I need a diagram here

\subsection{W and M}

We now present the general form of inductive types, which is the W type. The standard notion of W in the HoTT book is given by $A : Type$ and $B : A \to Type$, which is written as $W_{a : A} B (a)$. It is equipped with a single constructor $sup : \prod_{a : A} (B (a) \to W_{x : A} B (x)) \to W_{x : A} B (x)$. Notice that this definition is equivalent to the following container definition:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{sup}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaBound{SP}\<%
\end{code}

This definition implies that any inductive type can be characterized by a container functor algebra. Indeed, we can retrieve an equivalent definition of natural number through the maybe container.

\begin{code}%
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\<%
\\
\>[0]\AgdaFunction{⊤⊎Cont}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{◃}}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{⊤}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{W}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Dually, the general form of coinductive types - M type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{SP}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cont}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{inf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟦}}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⟧}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{M}\AgdaSpace{}%
\AgdaBound{SP}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{M}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\<%
\\
\>[0]\AgdaFunction{ℕ∞'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{M}\AgdaSpace{}%
\AgdaFunction{⊤⊎Cont}\<%
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\llbracket SP \rrbracket (W\;SP) \arrow[r, "\llbracket SP \rrbracket (fold\;\alpha)"] \arrow[d, "sup"]
& \llbracket SP \rrbracket X \arrow[d, "\alpha"] \\
W\;SP \arrow[r, "(fold\;\alpha)"]
& X
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& M\;SP \arrow[d, "inf"] \\
\llbracket SP \rrbracket X \arrow[r, "\llbracket SP \rrbracket (unfold\;\alpha^{-})"]
& \llbracket SP \rrbracket (M\;SP)
\end{tikzcd}
\]

As a conclusion, W and M are essentially \mu and \nu:

\[ W(S \triangleleft P) \cong \mu X. \llbracket S \triangleleft P \rrbracket X \]
\[ M(S \triangleleft P) \cong \nu X. \llbracket S \triangleleft P \rrbracket X \]

\section{Categories with Families}

The Categories with Families (CwFs) are categorical framework for interpreting dependent type theory. They model core concepts like context formation, substitution, weakening, etc. However, CwFs are more related to an alternative type theory - a substitution calculus by Martin-Löf, in which the substitution is first class and explicitly formulated.

\subsection{Definition}

There are many equivalent ways to define CwFs, we only present one definition which is suitable for our formalization. A CwF is given by:

\begin{itemize}
  \item{A category \textbf{C}. Its objects is a set of contexts, denoted by \Gamma, \Delta, etc, Its morphisms is a set of context substitutions, denoted by \gamma, \delta, etc. We call the objects type $Con$ and morphisms type $Tms$ (or $Subst$).
  
  Categorical rules for \textbf{C}:

  \begin{align*}
    id_{\Gamma} \circ \gamma & = \gamma \\
    \gamma \circ id_{\Gamma} & = \gamma \\
    (\gamma \circ \delta) \circ \theta & = \gamma \circ (\delta \circ \theta) \\
  \end{align*}
  }

  \item{A terminal object $\bullet : Con$ which represents the empty context, with the terminal map $\epsilon_{\Gamma} : Tms\;\Gamma\;\bullet$ which represents the empty substitution. 
  
  Universal property of $\bullet$:

  \begin{align*}
    \epsilon_{\Gamma} \circ \gamma & = \epsilon_{\Gamma} \\
    id_{\bullet} & = \epsilon_{\bullet} \\
  \end{align*}
  }

  \item{A presheaf $Ty : \textbf{C}^{op} \to \textbf{Set}$ which represents a set of types of a given context $\Gamma$. We use A, B, etc. to denote type. For each $\gamma : Tms (\Delta, \Gamma)$, we also define a special syntax $\_[\gamma] : Ty(\Gamma) \to Ty(\Delta)$ for the mapping morphisms part of $Ty$.

  Functoriality of $Ty$:

  \begin{align*}
    A [id_{\Gamma}] & = A \\
    A [\gamma \circ \delta] & = A [\gamma] [\delta] \\
  \end{align*}
  }

  \item{A presheaf 
  $Tm : (\int_{\textbf{C}})^{op} \to \textbf{Set}$ 
  which represents a set of terms of a given type $Ty(\Gamma)$. We use a, b, etc. to denote terms. For each $\gamma : Tms (\Delta, \Gamma)$ and $A : Ty(\Gamma)$, we also define a special syntax $\_[\gamma] : Tm(\Gamma, A) \to Tm(\Delta, A [\gamma])$ for the mapping morphisms part of $Tm$.

  Functoriality of $Ty$:

  \begin{align*}
    a [id_{\Gamma}] & = a \\
    a [\gamma \circ \delta] & = a [\gamma] [\delta] \\
  \end{align*}
  }

\item{A comprehension operation, which represents the context extensions. For each $\Gamma : Con$ and $A : Ty(\Gamma)$, there is an extended context $\Gamma \triangleright A$. For each $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm (\Delta, A[\gamma])$, there is an extended substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$. For each $\gamma : Tms (\Delta, \Gamma \triangleright A)$, there is a projection from $\gamma$ to $Tms (\Delta, \Gamma)$ that forgets the top variable, denoted by $\pi_1$; and a projection from $\gamma$ to an unique term $a : Tm (\Delta, A[\pi_1 \gamma])$ which essentially is the variable being forgotten, denoted by $\pi_2$.

The comprehension also comes with an universal property that, for every $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm(\Gamma , A[\gamma])$, there exists a unique substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$, such that:

  \begin{align*}
    \pi_1\;(\gamma, a) & = \gamma \\
    \pi_2\;(\gamma, a) & = a \\
    (\pi_1\;\gamma , \pi_2\;\gamma) & = \gamma \\
    (\delta, a) \circ \gamma & = (\delta \circ \gamma , a) \\
  \end{align*}
  }
  
\end{itemize}

\subsection{Adding Functions}

The CwF on its own typically does not say anything about types. We can add dependent function types to the framework separately.

For each $\Gamma : Con$, $A : Ty(\Gamma)$ and $B : Ty(\Gamma \triangleright A)$, there exist a dependent function type $\Pi (A, B) : Ty(\Gamma)$. For each $b : Tm(\Gamma \triangleright A, B)$, there is a function $lam(b) : Tm (\Gamma, \Pi (A, B))$. Inversely, for each $f : Tm(\Gamma, \Pi (A, B))$, there is a term $app(f) : Tm(\Gamma \triangleright A, B)$.

Rules for $lam$ and $app$, which are essentially \beta-rule and \eta-rule:

\begin{align*}
  app (lam (a)) & = a \\
  lam (app (f)) & = f \\
\end{align*}

In order to define the substitutions under $\Pi$, $lam$ and $app$, we need to first construct context substitution lifting operation: for each $\gamma : Tms (\Delta, \Gamma)$, it can be lifted to $\gamma \uparrow : Tms (\Delta \triangleright A [\gamma], \Gamma \triangleright A)$ by arbitrary $A : Ty(\Gamma)$.

Rules for substitution lifting and functions under substitutions.

\begin{align*}
  \gamma \uparrow & = \gamma \circ (\pi_1\;id) , \pi_2\;id \\
  (\Pi(A,B)) [\gamma] &= \Pi (A [\gamma], B [\gamma \uparrow]) \\
  (lam (a)) [\gamma] &= lam (t [\gamma \uparrow]) \\
  (app (f)) [\gamma \uparrow] &= app (f [\gamma]) \\
\end{align*}

\section{Normalization by Hereditary Substitutions}

We introduce the hereditary substitutions technique for \lambda-calculus normalization. To build the syntax of \lambda-calculus, we first define a simple syntax for types and contexts. We use A, B, etc. to range over types and \Gamma, \Delta, etc. to range over contexts.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{*}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{∙}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{20}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ty}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{Θ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\end{code}

\subsubsection*{De Bruijn Indices}

The De Bruijn indices are adopted to capture variables. The idea is to replace the name of variable in context with number, with the innermost (rightmost) variable gets index 0 and outermost (leftmost) variable gets the biggest index. For example $\lambda x.\lambda y.x$ in de bruijn form is $\lambda.\lambda.1$. We use x, y, etc. to range over variables.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\end{code}

\subsubsection*{\lambda-Terms}

The \lambda-terms follows the normal convention, which is either a variable, or a \lambda-abstraction, or a term application:

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{var}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{app}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\end{code}

\subsubsection*{Normal Forms}

Normalized \lambda-terms are defined as either: \lambda-abstractions of normal forms; or neutral terms, where neutral terms are variables applied to lists of normal forms, called the spines. We can mutually define them as:

\begin{code}[hide]%
\>[0]\AgdaKeyword{mutual}\<%
\end{code}

\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaInductiveConstructor{ne}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ty}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{ε}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\end{code}

\subsubsection*{Normalization}

\begin{code}[hide]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Con}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Con}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Γ}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\<%
\\
\>[0]\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{EqV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{EqV}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{x}\<%
\\
%
\>[2]\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{EqV}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{EqV}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\<%
\\
\>[0]\AgdaFunction{eq}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{eq}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{x}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{mutual}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{wkNe}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{wkv}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ns}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
%
\>[2]\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ns}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{snocSp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
\>[0]\AgdaFunction{snocSp}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{snocSp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{snocSp}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{mutual}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ne}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{*}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{e}\<%
\\
%
\>[2]\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ne2nf}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{snocSp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{wkSp}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{ns}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSymbol{)))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}[\AgdaUnderscore{}:=\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{vs}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaFunction{wkNf}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{eq}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{same}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{diff}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{x}}\AgdaSpace{}%
\AgdaBound{y'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\AgdaUnderscore{}:=\AgdaUnderscore{}>}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Var}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaGeneralizable{C}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{ts}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ts}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{>}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}◇\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Sp}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\<%
\\
%
\>[2]\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{us}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{napp}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◇}}\AgdaSpace{}%
\AgdaBound{us}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{B}\<%
\\
%
\>[2]\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaInductiveConstructor{vz}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{:=}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\<%
\end{code}

In TODO, they canonical normalizer for \lambda-calculi which computes every \lambda-term to its normal form. However, we should not go through the full implementation in details, but just illustrating the key components.

A variable is normalized by performing \eta-expansion to the fullest extent possible, defined by a function \AgdaFunction{nvar}. For example, a variable with type $(* \to *) \to * \to *$:

\[ H \rightarrow_{\eta} \lambda F. H\;F \rightarrow_{\eta} \lambda X. \lambda F. H\;F\;X \]

The application case is more involved, where it is the actual hereditary substitutions happening. The substitutions under normal forms are mutually defined with substitutions under neutral terms and spines. The \AgdaFunction{napp} launches the whole process by substitutes the top variable of first term by the second term.

Finally, we obtain the normalization function that \beta-reduces and \eta-expands simply typed terms.

\begin{code}%
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tm}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Nf}\AgdaSpace{}%
\AgdaGeneralizable{Γ}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{var}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{nvar}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lam}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{nf}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{app}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaBound{u}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{napp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nf}\AgdaSpace{}%
\AgdaBound{u}\AgdaSymbol{)}\<%
\end{code}

It is proved that the normalizer is complete and sound, but we should omit the proofs here.

\section{Questions}

\subsection{Bush}

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{coinductive}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{head}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
%
\>[4]\AgdaField{tail}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Bush}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Bush}\<%
\end{code}

How do we represent $Bush\;X$ as a M type? It turns out that previews scheme is no longer applicable. To address the issue, the key is to lift the space from $Set$ to $Set \to Set$. We can show $Bush$ on its own is the ``higher'' terminal coalgebra of a ``higher'' endofunctor $H$, where it is defined as:

\begin{align*}
& H : (Set \to Set) \to Set \to Set \\
& H (F) (X) = X \times F (F (X)) \\
\end{align*}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
F \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& Bush \arrow[d, "{<head,tail>}"] \\
H\;F \arrow[r, "H\;(unfold\;\alpha^{-})"]
& H\;Bush
\end{tikzcd}
\]