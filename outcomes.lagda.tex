\chapter{Research Outcomes}

\begin{code}[hide]
open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Product

open import Level renaming (zero to lzero; suc to lsuc)

Type : Set₁
Type = Set

Type₁ : Set₂
Type₁ = Set₁
\end{code}

\section{Higher-Order Containers}

\subsection{Syntax}

\begin{code}[hide]
infixr 20 _⇒_
data Ty : Type where
  * : Ty
  _⇒_ : Ty → Ty → Ty

variable A B C : Ty

infixl 5 _▹_
data Con : Type where
  ∙   : Con
  _▹_ : Con → Ty → Con

variable Γ Δ Θ : Con

data Var : Con → Ty → Type where
  vz : Var (Γ ▹ A) A
  vs : Var Γ A → Var (Γ ▹ B) A

variable x y : Var Γ A
\end{code}

To establish the syntax of higher containers, we begin by reviewing the first-order case. 

\begin{code}
List : Type → Type
List X = ⊤ ⊎ X ⊎ X × X ⊎ X × X × X {- ⊎ ... -}
\end{code}

For example, list can be viewed as \texttt{ℕ}-nary coproducts of \texttt{Fin n}-nary (for \texttt{n : ℕ}) products of \texttt{X}. The essence of coproducts and products are captured by shapes and positions correspondingly.

Now observe a second-order function \texttt{H}.

\begin{code}
H : (Type → Type) → Type → Type
H F X = X ⊎ F (F X)
\end{code}

Similar to a first-order term, \texttt{H} is also a coproduct of some sub-terms, so we need to keep the shape. The difference is that, under each shape we now need to keep track of the positions for both input variables \texttt{X} and \texttt{F}. Notably, the sub-term \texttt{F (F X)} is defined as nested term applications. It implies that, we need to add recursive structures for each occurrence of term that is not fully saturated.

It leads to the syntax of higher containers. They are like normalized simply typed \lambda-terms that are closed under products and coproducts. We therefore borrow the syntax of normal forms from previous section.

\begin{code}[hide]
mutual
\end{code}

\begin{code}
  data Nf : Con → Ty → Type₁ where
    lam : Nf (Γ ▹ A) B → Nf Γ (A ⇒ B)
    ne  : Ne Γ * → Nf Γ *

  record Ne (Γ : Con) (B : Ty) : Type₁ where
    constructor _◃_◃_
    inductive
    field
      S : Type
      P : Var Γ A → S → Type
      R : (x : Var Γ A) (s : S) (p : P x s) → Sp Γ A B

  data Sp : Con → Ty → Ty → Type₁ where
    ε   : Sp Γ A A
    _,_ : Nf Γ A → Sp Γ B C → Sp Γ (A ⇒ B) C
\end{code}

\begin{code}[hide]
  variable t u v : Nf Γ A
  variable spr tql : Ne Γ A
  variable ts us : Sp Γ A B
\end{code}

In this definition, \texttt{Nf} and \texttt{Sp} stay exact the same. \texttt{Ne} is the core definition of containers, which is defined as a type \texttt{S} represents shapes; a type family \texttt{P} indexed by variables and shape, represents positions; a type family \texttt{R} indexed by variables, shape and positions, represents recursive structures spine.

Finally, higher-order containers are defined as closed (with empty context) normal forms. We would therefore say \texttt{Nf} and \texttt{HCont} interchangeablely for the rest of formalization. 

\begin{code}
HCont : Ty → Type₁
HCont A = Nf ∙ A
\end{code}

\subsection{Semantics}

We wish to interpret higher containers to higher functors. But before defining the higher functoriality, we first interpret higher containers to functions. We need to first interpret types, contexts and variables:

\begin{code}
⟦_⟧t : Ty → Type₁
⟦ * ⟧t = Type
⟦ A ⇒ B ⟧t = ⟦ A ⟧t → ⟦ B ⟧t

⟦_⟧c : Con → Type₁
⟦ ∙ ⟧c = Lift (lsuc lzero) ⊤
⟦ Γ ▹ A ⟧c = ⟦ Γ ⟧c × ⟦ A ⟧t

⟦_⟧v : Var Γ A → ⟦ Γ ⟧c → ⟦ A ⟧t
⟦ vz ⟧v (as , a) = a
⟦ vs x ⟧v (as , a) = ⟦ x ⟧v as
\end{code}

We mutually define the semantics of \texttt{Nf}, \texttt{Ne} and \texttt{Sp}. Again, higher containers are just special cases of normal forms.

\begin{code}[hide]
mutual
\end{code}

\begin{code}
  ⟦_⟧nf : Nf Γ A → ⟦ Γ ⟧c → ⟦ A ⟧t
  ⟦ lam t ⟧nf as a = ⟦ t ⟧nf (as , a)
  ⟦ ne spr ⟧nf as = ⟦ spr ⟧ne as

  ⟦_⟧ne : Ne Γ * → ⟦ Γ ⟧c → Type
  ⟦_⟧ne {Γ} (S ◃ P ◃ R) as =
    Σ[ s ∈ S ] ({A : Ty} (x : Var Γ A) (p : P x s)
      → ⟦ R x s p ⟧sp as (⟦ x ⟧v as))

  ⟦_⟧sp : Sp Γ A B → ⟦ Γ ⟧c → ⟦ A ⟧t → ⟦ B ⟧t
  ⟦ ε ⟧sp as a = a
  ⟦ t , ts ⟧sp as f = ⟦ ts ⟧sp as (f (⟦ t ⟧nf as))
\end{code}

\begin{code}
⟦_⟧hcont : HCont A → ⟦ A ⟧t
⟦ x ⟧hcont = ⟦ x ⟧nf (lift tt)
\end{code}

\subsubsection{Normalization}

\begin{code}[hide]
app : Nf Γ (A ⇒ B) → Nf (Γ ▹ A) B
app (lam t) = t

en : Nf Γ * → Ne Γ *
en (ne spr) = spr

_-_ : (Γ : Con) → Var Γ A → Con
∙ - ()
(Γ ▹ A) - vz = Γ
(Γ ▹ A) - (vs x) = (Γ - x) ▹ A

wkVar : (x : Var Γ A) → Var (Γ - x) B → Var Γ B
wkVar vz y = vs y
wkVar (vs x) vz = vz
wkVar (vs x) (vs y) = vs (wkVar x y)

data EqVar : Var Γ A → Var Γ B → Type where
  same : EqVar x x
  diff : (x : Var Γ A) (y : Var (Γ - x) B) → EqVar x (wkVar x y)

eq : (x : Var Γ A) (y : Var Γ B) → EqVar x y
eq vz vz = same
eq vz (vs y) = diff vz y
eq (vs x) vz = diff (vs x) vz
eq (vs x) (vs y) with eq x y
eq (vs x) (vs .x)            | same = same
eq (vs x) (vs .(wkVar x y')) | diff .x y' = diff (vs x) (vs y')

mutual
  wkNf : (x : Var Γ A) → Nf (Γ - x) B → Nf Γ B
  wkNf x (lam t) = lam (wkNf (vs x) t)
  wkNf x (ne spr) = ne (wkNe x spr)

  wkNe : (x : Var Γ A) → Ne (Γ - x) B → Ne Γ B
  wkNe {Γ} {A} {C} x (S ◃ P ◃ R) = S ◃ P' ◃ R'
    where
    P' : Var Γ B → S → Type
    P' y  s with eq x y
    P' .x s | same = ⊥
    P' y  s | diff .x y' = P y' s

    R' : (y : Var Γ B) (s : S) → P' y s → Sp Γ B C
    R' y s p with eq x y
    R' y s p | diff .x y' = wkSp x (R y' s p)

  wkSp : (x : Var Γ A) → Sp (Γ - x) B C → Sp Γ B C
  wkSp x ε = ε
  wkSp x (t , ts) = wkNf x t , wkSp x ts

appSp : Sp Γ A (B ⇒ C) → Nf Γ B → Sp Γ A C
appSp ε u = u , ε
appSp (t , ts) u = t , appSp ts u

nvar : Var Γ A → Nf Γ A

ne2nf : Ne Γ A → Nf Γ A

nvar {Γ} {B} x = ne2nf (S ◃ P ◃ R)
  where
  S : Type
  S = ⊤

  P : Var Γ A → S → Type
  P y  tt with eq x y
  P .x tt | same = ⊤
  P y  tt | diff .x y' = ⊥

  R : (y : Var Γ A) (s : S) → P y s → Sp Γ A B
  R y tt p with eq x y
  R .x tt p | same = ε
  R y tt () | diff .x y'

ne2nf {Γ} {*} spr = ne spr
ne2nf {Γ} {A ⇒ C} (S ◃ P ◃ R) = lam (ne2nf (S ◃ P' ◃ R'))
  where
  P' : Var (Γ ▹ A) B → S → Type
  P' vz s = ⊥
  P' (vs x) s = P x s

  R' : (x : Var (Γ ▹ A) B) (s : S) → P' x s → Sp (Γ ▹ A) B C
  R' vz s ()
  R' (vs x) s p = appSp (wkSp vz (R x s p)) (nvar vz)

{- Normalization -}

mutual
  _[_:=_] : Nf Γ B → (x : Var Γ A) → Nf (Γ - x) A → Nf (Γ - x) B
  lam t [ x := u ] = lam (t [ vs x := wkNf vz u ])
  ne {Γ} (S ◃ P ◃ R) [ x := u ] = ne (S ◃ P' ◃ R')
    where
    P' : Var (Γ - x) A → S → Type
    P' y s = P (wkVar x y) s

    R' : (y : Var (Γ - x) A) (s : S) → P' y s → Sp (Γ - x) A *
    R' y s p = R (wkVar x y) s p < x := u >

  _<_:=_> : Sp Γ B C → (x : Var Γ A) → Nf (Γ - x) A → Sp (Γ - x) B C
  ε < x := u > = ε
  (t , ts) < x := u > = (t [ x := u ]) , (ts < x := u >)

  _◇_ : Nf Γ A → Sp Γ A B → Nf Γ B
  t ◇ ε = t
  t ◇ (u , us) = napp t u ◇ us
\end{code}

\begin{code}
  napp : Nf Γ (A ⇒ B) → Nf Γ A → Nf Γ B
  napp (lam t) u = t [ vz := u ]
\end{code}

TODO

\subsubsection*{Categorical Structures}

For each \texttt{A : Ty}, there is a category of higher containers \texttt{HCONT A}. We define the morphisms between normal forms:

\begin{code}[hide]
mutual
\end{code}

\begin{code}
  data NfHom : Nf Γ A → Nf Γ A → Type₁ where
    lam : NfHom t u → NfHom (lam t) (lam u)
    ne  : NeHom spr tql → NfHom (ne spr) (ne tql)

  record NeHom {Γ} {B} (spr tql : Ne Γ B) : Type₁ where
    constructor _◃_◃_
    inductive
    open Ne spr
    open Ne tql renaming (S to T; P to Q; R to L)
    field
      f : S → T
      g : (x : Var Γ A) (s : S) → Q x (f s) → P x s
      h : (x : Var Γ A) (s : S) (q : Q x (f s))
        → SpHom (R x s (g x s q)) (L x (f s) q)
        
  data SpHom : Sp Γ A B → Sp Γ A B → Type₁ where
    ε   : SpHom ts ts
    _,_ : NfHom t u → SpHom ts us → SpHom (t , ts) (u , us)
\end{code}

\subsubsection*{Algebraic Structures}

\begin{code}
onenf : Nf Γ A
onenf {Γ} {*} = ne (⊤ ◃ (λ{ x tt → ⊥ }) ◃ λ{ x tt () })
onenf {Γ} {A ⇒ B} = lam onenf

zeronf : Nf Γ A
zeronf {Γ} {*} = ne (⊥ ◃ (λ x ()) ◃ (λ x ()))
zeronf {Γ} {A ⇒ B} = lam zeronf

Πnf : (I : Type) → (I → Nf Γ A) → Nf Γ A
Πnf {Γ} {A ⇒ B} I ts = lam (Πnf I (λ i → app (ts i)))
Πnf {Γ} {*} I ts = ne (S ◃ P ◃ R)
  where
  S : Type
  S = (i : I) → en (ts i) .Ne.S

  P : Var Γ A → S → Type
  P x f = Σ[ i ∈ I ] en (ts i) .Ne.P x (f i)

  R : (x : Var Γ A) (s : S) → P x s → Sp Γ A *
  R x f (i , p) = en (ts i) .Ne.R x (f i) p

Σnf : (I : Type) → (I → Nf Γ A) → Nf Γ A
Σnf {Γ} {A ⇒ B} I ts = lam (Σnf I (λ i → app (ts i)))
Σnf {Γ} {*} I ts = ne (S ◃ P ◃ R)
  where
  S : Type
  S = Σ[ i ∈ I ] en (ts i) .Ne.S

  P : Var Γ A → S → Type
  P x (i , s) = en (ts i) .Ne.P x s

  R : (x : Var Γ A) (s : S) → P x s → Sp Γ A *
  R x (i , s) p = en (ts i) .Ne.R x s p
\end{code}

\begin{code}[hide]
infix 2 Πnf-syntax
Πnf-syntax : (I : Type) → (I → Nf Γ A) → Nf Γ A
Πnf-syntax = Πnf
syntax Πnf-syntax A (λ x → B) = Πnf[ x ∈ A ] B

infix 2 Σnf-syntax
Σnf-syntax : (I : Type) → (I → Nf Γ A) → Nf Γ A
Σnf-syntax = Πnf
syntax Σnf-syntax A (λ x → B) = Σnf[ x ∈ A ] B
\end{code}


\subsection{Simply Typed Categories with Families}

We show that the higher containers get rise to a SCwF with functions, where \texttt{Ty} is \texttt{Ty}, \texttt{Con} is \texttt{Con}, and \texttt{Tm} is \texttt{Nf}. We need to define the syntax for context substitutions.

\begin{code}
data Nfs : Con → Con → Type₁ where
  ε   : Nfs Γ ∙
  _,_ : Nfs Δ Γ → Nf Δ A → Nfs Δ (Γ ▹ A)
\end{code}

\begin{code}[hide]
variable γ δ θ : Nfs Δ Γ
\end{code}

Similar to \texttt{Tms}, the \texttt{Nfs} is a list of normal forms.

\begin{code}[hide]
wkNfs : (x : Var Δ A) → Nfs (Δ - x) Γ → Nfs Δ Γ
wkNfs x ε = ε
wkNfs x (γ , t) = wkNfs x γ , wkNf x t

_↑ : Nfs Δ Γ → Nfs (Δ ▹ A) (Γ ▹ A)
γ ↑ = wkNfs vz γ , nvar vz

id : Nfs Γ Γ
id {∙} = ε
id {Γ ▹ A} = id ↑

subVar : Var Γ A → Nfs Δ Γ → Nf Δ A
subVar vz (γ , t) = t
subVar (vs x) (γ , t) = subVar x γ

foldSp : Nf Γ A → Sp Γ A B → Nf Γ B
foldSp t ε = t
foldSp t (u , us) = foldSp (napp t u) us
\end{code}

\begin{code}
mutual
  _[_] : Nf Γ A → Nfs Δ Γ → Nf Δ A
  lam t [ γ ] = lam (t [ γ ↑ ])
  ne spr [ γ ] = spr [ γ ]ne2nf

  _[_]ne2nf : Ne Γ B → Nfs Δ Γ → Nf Δ B
  _[_]ne2nf {Γ} {B} {Δ} (S ◃ P ◃ R) γ =
    Σnf[ s ∈ S ] Πnf[ A ∈ Ty ] Πnf[ x ∈ Var Γ A ] Πnf[ p ∈ P x s ]
    foldSp {Δ} {A} (subVar x γ) (R x s p [ γ ]sp)

  _[_]sp : Sp Γ A B → Nfs Δ Γ → Sp Δ A B
  ε [ γ ]sp = ε
  (t , ts) [ γ ]sp = (t [ γ ]) , (ts [ γ ]sp)
\end{code}