\chapter{Conducted Research}

\begin{code}[hide]
{-# OPTIONS --guardedness #-}

open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Product
open import Function.Base
open import Relation.Binary.PropositionalEquality

Type : Set₁
Type = Set

Type₁ : Set₂
Type₁ = Set₁

variable X Y I : Type
\end{code}

In this section, we begin by reviewing related literature. We then introduce a categorical view of types, containers, W-types and M-types. We also introduce category with families - a model of type theory, and hereditary substitutions - a normalization technic for \lambda-calculus. Finally, we outline the current challenges.

\section{Literature Review}
TODO

\section{Types as Algebras}

\subsection{Inductive Types are Initial Algebras}

We use natural number as our example through this sections. Natural number \texttt{ℕ = \{0, 1, 2, 3, ...\}} can be defined as inductive type:
\begin{code}
data ℕ : Type where
  zero : ℕ
  suc : ℕ → ℕ
\end{code}

Given an endofunctor \AgdaBound{F} \AgdaSymbol{:} \AgdaPrimitive{Type} \AgdaFunction{⇒} \AgdaPrimitive{Type}, an algebra is defined as a carrier type \AgdaBound{A} \AgdaSymbol{:} \AgdaFunction{Type} and an evaluation function \AgdaBound{α} \AgdaSymbol{:} \AgdaBound{F} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A}. The morphisms between algebras \AgdaSymbol{(}\AgdaBound{A} \AgdaInductiveConstructor{,} \AgdaBound{α}\AgdaSymbol{)} and \AgdaSymbol{(}\AgdaBound{B} \AgdaInductiveConstructor{,} \AgdaBound{β}\AgdaSymbol{)} are given by a function \AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B} such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  \AgdaBound{F A} \arrow[r, "\AgdaBound{F f}"] \arrow[d, "\AgdaBound{α}"]
  & \AgdaBound{F B} \arrow[d, "\AgdaBound{β}"] \\
  \AgdaBound{A} \arrow[r, "\AgdaBound{f}"]
  & \AgdaBound{B}
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the \AgdaDatatype{⊤⊎\_} (\textbf{Maybe}) functor. To prove this, we first its constructors into an equivalent function form:
\begin{code}
[z,s] : ⊤ ⊎ ℕ → ℕ
[z,s] (inj₁ tt) = zero
[z,s] (inj₂ n) = suc n
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine \AgdaFunction{fold}:

\begin{code}
fold : (⊤ ⊎ X → X) → ℕ → X
fold α zero = α (inj₁ tt)
fold α (suc n) = α (inj₂ (fold α n))
\end{code}

then construct the mapping morphism part of \AgdaDatatype{⊤⊎\_}:

\begin{code}[hide]
⊤⊎₁ : (X → Y) → ⊤ ⊎ X → ⊤ ⊎ Y
⊤⊎₁ f (inj₁ tt) = inj₁ tt
⊤⊎₁ f (inj₂ x) = inj₂ (f x)
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaDatatype{⊤ ⊎ ℕ} \arrow[r, "\AgdaFunction{⊤⊎₁ } \AgdaSymbol{(}\AgdaFunction{fold }\AgdaBound{α}\AgdaSymbol{)}"] \arrow[d, "\AgdaFunction{[z,s]}"]
& \AgdaDatatype{⊤ ⊎ }\AgdaBound{X} \arrow[d, "\AgdaBound{α}"] \\
\AgdaDatatype{ℕ} \arrow[r, "\AgdaFunction{fold }\AgdaBound{α}"]
& \AgdaBound{X}
\end{tikzcd}
\]

\subsection{Coinductive Types are Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. Now we inverse all the morphisms in above diagram and therefore dualize all concepts. We define conatural number as coinductive type and reverse \AgdaFunction{fold} to \AgdaFunction{unfold}:

\begin{code}
record ℕ∞ : Type where
  coinductive
  field
    pred∞ : ⊤ ⊎ ℕ∞
open ℕ∞

unfold : (X → ⊤ ⊎ X) → X → ℕ∞
pred∞ (unfold α⁻ x) with α⁻ x 
... | inj₁ tt = inj₁ tt
... | inj₂ x' = inj₂ (unfold α⁻ x')
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{X} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaDatatype{ℕ∞} \arrow[d, "\AgdaField{pred∞}"] \\
\AgdaDatatype{⊤ ⊎ }\AgdaBound{X} \arrow[r, "\AgdaFunction{⊤⊎₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaDatatype{⊤ ⊎ ℕ∞}
\end{tikzcd}
\]

Therefore we get the result of coinductive types are terminal coalgebras for free.

\section{Containers}

\subsection{Strict Positivity}

Containers are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. One typical counterexample is \AgdaDatatype{Weird}:

\begin{code}
{-# NO_POSITIVITY_CHECK #-}
data Weird : Type where
  foo : (Weird → ⊥) → Weird
\end{code}

\AgdaDatatype{Weird} is not strictly positive, as \AgdaDatatype{Weird} itself appears on the left-side of \AgdaSymbol{→} in \AgdaInductiveConstructor{foo}. Losing strict positivity can cause issues like non-normalizable, non-terminating, inconsistency, etc. In this case, a empty type term can be constructed using \AgdaFunction{¬weird} which is inconsistent to empty definition:

\begin{code}
¬weird : Weird → ⊥
¬weird (foo x) = x (foo x)

bad : ⊥
bad = ¬weird (foo ¬weird)
\end{code}

\subsection{Syntax and Semantics}

A container is given by a shape \AgdaBound{S} and with each shape a position \AgdaBound{P}:

\begin{code}
record Cont : Type₁ where
  constructor _◃_
  field
    S : Type
    P : S → Type
\end{code}

\begin{code}[hide]
variable SP TQ : Cont
\end{code}

A container should give rise to a endofunctor \AgdaPrimitive{Type} \AgdaSymbol{⇒} \AgdaPrimitive{Type}. Again, we explicitly distinguish mapping objects part and mapping morphisms part of a functor:

\begin{code}
record ⟦_⟧₀ (SP : Cont) (X : Type) : Type where
  constructor _,_
  open Cont SP
  field
    s : S
    k : P s → X

⟦_⟧₁ : (SP : Cont) → (X → Y) → ⟦ SP ⟧₀ X → ⟦ SP ⟧₀ Y
⟦ SP ⟧₁ f (s , k) = s , f ∘ k
\end{code}

\subsection{Categorical Structure}

Containers and their morphisms form a category. The morphisms are defined as follow:

\begin{code}
record ContHom (SP TQ : Cont) : Type where
  constructor _◃_
  open Cont SP
  open Cont TQ renaming (S to T; P to Q)
  field
    f : S → T
    g : (s : S) → Q (f s) → P s
\end{code}

As containers give rise to functors, the morphisms of containers should naturally give rise to the morphisms of functors - the natural transformations:

\begin{code}
⟦_⟧Hom : ContHom SP TQ → (X : Type) → ⟦ SP ⟧₀ X → ⟦ TQ ⟧₀ X
⟦ f ◃ g ⟧Hom X (s , k) = f s , k ∘ g s
\end{code}

\subsection{Semiring Structure}

Containers are also known as \textbf{polynomial functors} as they forms a semiring structure. Namely, we can define one, zero, multiplication and addition for containers:

\begin{code}
oneC : Cont
oneC = ⊤ ◃ λ x → ⊥

zeroC : Cont
zeroC = ⊥ ◃ λ ()

_×C_ : Cont → Cont → Cont
(S ◃ P) ×C (T ◃ Q) = (S × T) ◃ λ (s , t) → P s ⊎ Q t

_⊎C_ : Cont → Cont → Cont
(S ◃ P) ⊎C (T ◃ Q) = (S ⊎ T) ◃ λ{ (inj₁ s) → P s ; (inj₂ t) → Q t }
\end{code}

such that the semiring laws should hold. In fact, both multiplication and addition are commutative, associative and left- and right-annihilated by their units. It turns out they also exactly correspond to the initial, terminal, product and coproduct of the containers. 

Even better, we can generalize \AgdaRecord{×} and \AgdaFunction{⊎} to \AgdaFunction{Π} and \AgdaRecord{Σ} for containers, which are finitary product and coproduct objects.

\begin{code}[hide]
module _ where
  open Cont
\end{code}

\begin{code}
  ΠC : (I → Cont) → Cont
  ΠC {I} SPs = ((i : I) → SPs i .S) ◃ λ f → Σ[ i ∈ I ] SPs i .P (f i)

  ΣC : (I → Cont) → Cont
  ΣC {I} SPs = (Σ[ i ∈ I ] SPs i .S) ◃ λ (i , s) → SPs i .P s
\end{code}

\subsection{W and M}

With containers, we now give the definition of general form of inductive types, which is the \AgdaDatatype{W} type:

\begin{code}
data W (SP : Cont) : Type where
  sup : ⟦ SP ⟧₀ (W SP) → W SP
\end{code}

From the definition, \AgdaDatatype{W} is an inductive type that specified by a container. In another word, any inductive type can be specified by a strictly positive functor. We can retrieve \AgdaDatatype{ℕ} through the \AgdaDatatype{⊤ ⊎} container:

\begin{code}
⊤⊎Cont : Cont
⊤⊎Cont = (⊤ ⊎ ⊤) ◃ λ{ (inj₁ tt) → ⊥ ; (inj₂ y) → ⊤ }

ℕW : Type
ℕW = W ⊤⊎Cont
\end{code}

Dually, the general form of coinductive types - \AgdaRecord{M} type is just the terminal coalgebra of containers. \AgdaRecord{W} and \AgdaRecord{ℕ∞} are defined as follow:

\begin{code}
record M (SP : Cont) : Type where
  coinductive
  field
    inf : ⟦ SP ⟧₀ (M SP)

ℕ∞M : Type
ℕ∞M = M ⊤⊎Cont
\end{code}

Finally, we have the following commutative diagrams for \AgdaDatatype{W} and \AgdaRecord{M}:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧₀ }\AgdaSymbol{(}\AgdaDatatype{W }\AgdaBound{SP}\AgdaSymbol{)} \arrow[r, "\AgdaFunction{⟦ }\AgdaBound{SP }\AgdaFunction{⟧₁ }\AgdaSymbol{(}\AgdaFunction{fold }\AgdaBound{α}\AgdaSymbol{)}"] \arrow[d, "\AgdaInductiveConstructor{sup}"]
& \AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧₀ }\AgdaBound{X} \arrow[d, "\AgdaBound{α}"] \\
\AgdaDatatype{W }\AgdaBound{SP} \arrow[r, "\AgdaFunction{fold }\AgdaBound{α}"]
& \AgdaBound{X}
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{X} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaRecord{M } \AgdaBound{SP}\arrow[d, "\AgdaField{inf}"] \\
\AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧₀ }\AgdaBound{X} \arrow[r, "\AgdaFunction{⟦ }\AgdaBound{SP }\AgdaFunction{⟧₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧₀ }\AgdaSymbol{(}\AgdaRecord{M }\AgdaBound{SP}\AgdaSymbol{)}
\end{tikzcd}
\]

We have now showed inductive types are initial algebras and coinductive types are terminal coalgebras.

\section{Simply-Typed Category with Families}

\section{Hereditary Substitutions}

We introduce the hereditary substitutions for \lambda-calculus normalization. To build the syntax of \lambda-calculus, we first define types and contexts:

\begin{code}
data Ty : Type where
  *   : Ty
  _⇒_ : Ty → Ty → Ty

data Ctx : Type where
  ∙   : Ctx
  _▹_ : Ctx → Ty → Ctx
\end{code}

\begin{code}[hide]
variable A B C : Ty
variable Γ Δ : Ctx
\end{code}

We adopt the De Bruijn indices to represent bound variables without explicit naming.

\begin{code}
data Var : Ctx → Ty → Type where
  vz : Var (Γ ▹ A) A
  vs : Var Γ A → Var (Γ ▹ B) A
\end{code}

\begin{code}[hide]
mutual
\end{code}

The normal form \lambda-terms \AgdaDatatype{Nf} are defined as either:

\begin{itemize}
  \item{\lambda-abstractions of \AgdaDatatype{Nf};}
  \item{Or neutral terms \AgdaDatatype{Ne}, where \AgdaDatatype{Ne} are variables \AgdaDatatype{Var} applied to lists of \AgdaDatatype{Nf}, called spine \AgdaDatatype{Sp}}.
\end{itemize}

\begin{code}
  data Nf : Ctx → Ty → Type where
    lam : Nf (Γ ▹ A) B → Nf Γ (A ⇒ B)
    ne  : Ne Γ * → Nf Γ *

  data Ne : Ctx → Ty → Type where
    _,_ : Var Γ A → Sp Γ A B → Ne Γ B

  data Sp : Ctx → Ty → Ty → Type where
    ε   : Sp Γ A A
    _,_ : Nf Γ A → Sp Γ B C → Sp Γ (A ⇒ B) C
\end{code}

\section{Questions}

TODO

\subsection{Bush}

\begin{code}
record Bush₀ (X : Type) : Type where
  coinductive
  field
    head : X
    tail : Bush₀ (Bush₀ X)
open Bush₀

{-# TERMINATING #-}
Bush₁ : (X → Y) → Bush₀ X → Bush₀ Y
head (Bush₁ f a) = f (head a)
tail (Bush₁ f a) = Bush₁ (Bush₁ f) (tail a)
\end{code}

How do we represent \AgdaRecord{Bush} \AgdaBound{X} as a \AgdaRecord{M} type? It turns out that previews scheme is no longer applicable.

The key observation is to lift the space from \AgdaPrimitive{Type} to \AgdaPrimitive{Type} \AgdaSymbol{→} \AgdaPrimitive{Type}. We can show \AgdaRecord{Bush} is the terminal coalgebra of a ``higher'' endofunctor. We need to also define a ``higher'' algebra:

\begin{code}
H : (Type → Type) → Type → Type
H F X = X × F (F X)
\end{code}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{F} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaRecord{Bush₀} \arrow[d, "\AgdaFunction{< }\AgdaField{head }\AgdaFunction{, }\AgdaField{tail }\AgdaFunction{>}"] \\
\AgdaFunction{H }\AgdaBound{F} \arrow[r, "\AgdaDatatype{H₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaFunction{H }\AgdaRecord{Bush₀}
\end{tikzcd}
\]