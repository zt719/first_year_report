\chapter{Conducted Research}

\begin{code}[hide]
{-# OPTIONS --guardedness #-}

open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Product
open import Function.Base
open import Relation.Binary.PropositionalEquality

Type : Set₁
Type = Set

Type₁ : Set₂
Type₁ = Set₁

variable X Y I : Type
\end{code}

In this section, we begin by reviewing related literature. We then introduce a categorical view of types, containers, W type and M type. To facilitate later definition of higher containers in the research outcomes section, we also present related topics including categories with families, and normalization by hereditary substitutions. Finally, we outline the current challenges in this area.

\section{Literature Review}
TODO

\section{Types as Algebras}

\subsection{Inductive Types as Initial Algebras}

We use natural number as our example through this sections. Natural number \texttt{ℕ = \{0, 1, 2, 3, ...\}} can be defined as inductive type:
\begin{code}
data ℕ : Type where
  zero : ℕ
  suc : ℕ → ℕ
\end{code}

Given an endofunctor \AgdaBound{F} \AgdaSymbol{:} \AgdaPrimitive{Type} \AgdaFunction{⇒} \AgdaPrimitive{Type}, an algebra is defined as a carrier type \AgdaBound{A} \AgdaSymbol{:} \AgdaFunction{Type} and an evaluation function \AgdaBound{α} \AgdaSymbol{:} \AgdaBound{F} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{A}. The morphisms between algebras \AgdaSymbol{(}\AgdaBound{A} \AgdaInductiveConstructor{,} \AgdaBound{α}\AgdaSymbol{)} and \AgdaSymbol{(}\AgdaBound{B} \AgdaInductiveConstructor{,} \AgdaBound{β}\AgdaSymbol{)} are given by a function \AgdaBound{f} \AgdaSymbol{:} \AgdaBound{A} \AgdaSymbol{→} \AgdaBound{B} such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  \AgdaBound{F A} \arrow[r, "\AgdaBound{F f}"] \arrow[d, "\AgdaBound{α}"]
  & \AgdaBound{F B} \arrow[d, "\AgdaBound{β}"] \\
  \AgdaBound{A} \arrow[r, "\AgdaBound{f}"]
  & \AgdaBound{B}
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the \texttt{⊤⊎\_} maybe functor. To prove this, we first its constructors into an equivalent function form:

\begin{code}
[z,s] : ⊤ ⊎ ℕ → ℕ
[z,s] (inj₁ tt) = zero
[z,s] (inj₂ n) = suc n
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding:

\begin{code}
fold : (⊤ ⊎ X → X) → ℕ → X
fold α zero = α (inj₁ tt)
fold α (suc n) = α (inj₂ (fold α n))
\end{code}

then construct the mapping morphism part of maybe functor:

\begin{code}[hide]
⊤⊎₁ : (X → Y) → ⊤ ⊎ X → ⊤ ⊎ Y
⊤⊎₁ f (inj₁ tt) = inj₁ tt
⊤⊎₁ f (inj₂ x) = inj₂ (f x)
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaDatatype{⊤ ⊎ ℕ} \arrow[r, "\AgdaFunction{⊤⊎₁ } \AgdaSymbol{(}\AgdaFunction{fold }\AgdaBound{α}\AgdaSymbol{)}"] \arrow[d, "\AgdaFunction{[z,s]}"]
& \AgdaDatatype{⊤ ⊎ }\AgdaBound{X} \arrow[d, "\AgdaBound{α}"] \\
\AgdaDatatype{ℕ} \arrow[r, "\AgdaFunction{fold }\AgdaBound{α}"]
& \AgdaBound{X}
\end{tikzcd}
\]

\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. Now we inverse all the morphisms in above diagram and therefore dualize all concepts. We define conatural number as coinductive type and unfolding:

\begin{code}
record ℕ∞ : Type where
  coinductive
  field
    pred∞ : ⊤ ⊎ ℕ∞
open ℕ∞

unfold : (X → ⊤ ⊎ X) → X → ℕ∞
pred∞ (unfold α⁻ x) with α⁻ x 
... | inj₁ tt = inj₁ tt
... | inj₂ x' = inj₂ (unfold α⁻ x')
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{X} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaDatatype{ℕ∞} \arrow[d, "\AgdaField{pred∞}"] \\
\AgdaDatatype{⊤ ⊎ }\AgdaBound{X} \arrow[r, "\AgdaFunction{⊤⊎₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaDatatype{⊤ ⊎ ℕ∞}
\end{tikzcd}
\]

Therefore we get the result of coinductive types are terminal coalgebras for free.

\section{Containers}

\subsection{Strict Positivity}

Containers are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}
{-# NO_POSITIVITY_CHECK #-}
data Weird : Type where
  foo : (Weird → ⊥) → Weird
\end{code}

\texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Losing strict positivity can cause issues like non-normalizable, non-terminating, inconsistency, etc. In this case, a empty type term can be constructed, which is inconsistent to empty definition:

\begin{code}
¬weird : Weird → ⊥
¬weird (foo x) = x (foo x)

bad : ⊥
bad = ¬weird (foo ¬weird)
\end{code}

\subsection{Syntax}

A normal container is given by a shape \texttt{S} and with each shape a position \texttt{P}:

\begin{code}
record Cont : Type₁ where
  constructor _◃_
  field
    S : Type
    P : S → Type
\end{code}

\begin{code}[hide]
variable SP TQ : Cont
\end{code}

Containers are used to describe generic type (or generic class). For example, a \AgdaDatatype{List} container is \AgdaDatatype{ℕ} \AgdaInductiveConstructor{◃} \AgdaDatatype{Fin}, which suggests a list should have countable many possible shapes, with each shape uniquely represents the length of list (or the number of elements).

\begin{code}
data Fin : ℕ → Type where
  zero : Fin (suc zero)
  suc  : ∀ {n} → Fin n → Fin (suc n)

ListC : Cont
ListC = ℕ ◃ Fin
\end{code}

\subsubsection*{Categorical Structures}

Containers and their morphisms form a category. The morphisms are defined as follow:

\begin{code}
record ContHom (SP TQ : Cont) : Type where
  constructor _◃_
  open Cont SP
  open Cont TQ renaming (S to T; P to Q)
  field
    f : S → T
    g : (s : S) → Q (f s) → P s
\end{code}

such that the identity morphisms and compositions exist.

The intuition behind morphism is the process manipulating and transferring data between data structures. The first component \AgdaField{f} tells how to map shapes and second component \AgdaField{g} defines how to obtain data. Notice that mapping in \AgdaField{g} is backward, because data could be lost or duplicated during the transfer. For example, to define the tail function on list:

\begin{code}
tailC : ContHom ListC ListC
tailC = f ◃ g
  where
  f : ℕ → ℕ
  f zero = zero
  f (suc n) = n

  g : (n : ℕ) → Fin (f n) → Fin n
  g zero ()
  g (suc n) x = suc x
\end{code}

\subsubsection*{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, zero, multiplication and addition for containers:

\begin{code}
oneC : Cont
oneC = ⊤ ◃ const ⊥

zeroC : Cont
zeroC = ⊥ ◃ ⊥-elim

_×C_ : Cont → Cont → Cont
(S ◃ P) ×C (T ◃ Q) = (S × T) ◃ λ (s , t) → P s ⊎ Q t

_⊎C_ : Cont → Cont → Cont
(S ◃ P) ⊎C (T ◃ Q) = (S ⊎ T) ◃ λ{ (inj₁ s) → P s ; (inj₂ t) → Q t }
\end{code}

such that the semiring laws should hold. In fact, both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. Moreover, they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers.

Even better, we can generalize the binary product and coproduct to finite product and coproduct in the category of containers.

\begin{code}[hide]
module _ where
  open Cont
\end{code}

\begin{code}
  ΠC : (I → Cont) → Cont
  ΠC {I} SPs = ((i : I) → SPs i .S) ◃ λ f → Σ[ i ∈ I ] SPs i .P (f i)

  ΣC : (I → Cont) → Cont
  ΣC {I} SPs = (Σ[ i ∈ I ] SPs i .S) ◃ λ (i , s) → SPs i .P s
\end{code}

\subsection{Semantics}

A container should give rise to a endofunctor of \texttt{Set}. Again, we explicitly distinguish mapping objects part and mapping morphisms part of a functor:

\begin{code}
record ⟦_⟧ (SP : Cont) (X : Type) : Type where
  constructor _,_
  open Cont SP
  field
    s : S
    k : P s → X

⟦_⟧₁ : (SP : Cont) → (X → Y) → ⟦ SP ⟧ X → ⟦ SP ⟧ Y
⟦ SP ⟧₁ f (s , k) = s , f ∘ k
\end{code}

As containers give rise to functors, the morphisms of containers should naturally give rise to the morphisms of functors - the natural transformations:

\begin{code}
⟦_⟧Hom : ContHom SP TQ → (X : Type) → ⟦ SP ⟧ X → ⟦ TQ ⟧ X
⟦ f ◃ g ⟧Hom X (s , k) = f s , k ∘ g s
\end{code}

\subsection{W and M}

We now present the general form of inductive types, which is the W type:

\begin{code}
data W (SP : Cont) : Type where
  sup : ⟦ SP ⟧ (W SP) → W SP
\end{code}

By definition, W is uniquely represented by an algebra specified by a container. In another word, any inductive type can be characterized by a containers. Indeed, we can retrieve an equivalent definition of natural number through the maybe container:

\begin{code}
⊤⊎Cont : Cont
⊤⊎Cont = (⊤ ⊎ ⊤) ◃ λ{ (inj₁ tt) → ⊥ ; (inj₂ y) → ⊤ }

ℕW : Type
ℕW = W ⊤⊎Cont
\end{code}

Dually, the general form of coinductive types - M type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}
record M (SP : Cont) : Type where
  coinductive
  field
    inf : ⟦ SP ⟧ (M SP)
open M

ℕ∞M : Type
ℕ∞M = M ⊤⊎Cont
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧ }\AgdaSymbol{(}\AgdaDatatype{W }\AgdaBound{SP}\AgdaSymbol{)} \arrow[r, "\AgdaFunction{⟦ }\AgdaBound{SP }\AgdaFunction{⟧₁ }\AgdaSymbol{(}\AgdaFunction{fold }\AgdaBound{α}\AgdaSymbol{)}"] \arrow[d, "\AgdaInductiveConstructor{sup}"]
& \AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧ }\AgdaBound{X} \arrow[d, "\AgdaBound{α}"] \\
\AgdaDatatype{W }\AgdaBound{SP} \arrow[r, "\AgdaFunction{fold }\AgdaBound{α}"]
& \AgdaBound{X}
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{X} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaRecord{M } \AgdaBound{SP}\arrow[d, "\AgdaField{inf}"] \\
\AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧ }\AgdaBound{X} \arrow[r, "\AgdaFunction{⟦ }\AgdaBound{SP }\AgdaFunction{⟧₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaRecord{⟦ }\AgdaBound{SP }\AgdaRecord{⟧ }\AgdaSymbol{(}\AgdaRecord{M }\AgdaBound{SP}\AgdaSymbol{)}
\end{tikzcd}
\]

We have now showed inductive types are initial algebras and coinductive types are terminal coalgebras.

\input{latex/scwfs}

\section{Normalization by Hereditary Substitutions}

We introduce the hereditary substitutions technique for \lambda-calculus normalization. To build the syntax of \lambda-calculus, we first define types (with a base type and function) and contexts:

\begin{code}
data Ty : Type where
  *   : Ty
  _⇒_ : Ty → Ty → Ty

data Con : Type where
  ∙   : Con
  _▹_ : Con → Ty → Con
\end{code}

\begin{code}[hide]
variable A B C : Ty
variable Γ Δ : Con
\end{code}

Adopting the De Bruijn indices to represent bound variables without explicit naming.

\begin{code}
data Var : Con → Ty → Type where
  vz : Var (Γ ▹ A) A
  vs : Var Γ A → Var (Γ ▹ B) A
\end{code}

The \lambda-terms follows the normal convention:

\begin{code}
data Tm : Con → Ty → Set where
  var : Var Γ A → Tm Γ A
  lam : Tm (Γ ▹ A) B → Tm Γ (A ⇒ B)
  app : Tm Γ (A ⇒ B) → Tm Γ A → Tm Γ B
\end{code}

\begin{code}[hide]
variable x y : Var Γ A
\end{code}

We also need to define the syntax of normal forms. A normalized \lambda-terms are defined as either: \lambda-abstractions of normal forms; or neutral terms, where neutral terms are variables applied to lists of normal forms, called the spines.

\begin{code}
mutual
  data Nf : Con → Ty → Type where
    lam : Nf (Γ ▹ A) B → Nf Γ (A ⇒ B)
    ne  : Ne Γ * → Nf Γ *

  data Ne : Con → Ty → Type where
    _,_ : Var Γ A → Sp Γ A B → Ne Γ B

  data Sp : Con → Ty → Ty → Type where
    ε   : Sp Γ A A
    _,_ : Nf Γ A → Sp Γ B C → Sp Γ (A ⇒ B) C
\end{code}

\begin{code}[hide]
_-_ : (Γ : Con) → Var Γ A → Con
(Γ ▹ A) - vz = Γ
(Γ ▹ A) - vs x = (Γ - x) ▹ A

wkv : (x : Var Γ A) → Var (Γ - x) B → Var Γ B
wkv vz y = vs y
wkv (vs x) vz = vz
wkv (vs x) (vs y) = vs (wkv x y)

data EqVar : Var Γ A → Var Γ B → Set where
  same : EqVar x x
  diff : (x : Var Γ A) (y : Var (Γ - x) B) → EqVar x (wkv x y)

eq : (x : Var Γ A) (y : Var Γ B) → EqVar x y
eq vz vz = same
eq vz (vs y) = diff vz y
eq (vs x) vz = diff (vs x) vz
eq (vs x) (vs y) with eq x y
... | same = same
... | diff .x y = diff (vs x) (vs y)

mutual
  wkNf : (x : Var Γ A) → Nf (Γ - x) B → Nf Γ B
  wkNf x (lam n) = lam (wkNf (vs x) n)
  wkNf x (ne e) = ne (wkNe x e)

  wkNe : (x : Var Γ A) → Ne (Γ - x) B → Ne Γ B
  wkNe x (v , ns) = wkv x v , wkSp x ns

  wkSp : (x : Var Γ A) → Sp (Γ - x) B C → Sp Γ B C
  wkSp x ε = ε
  wkSp x (n , ns) = wkNf x n , wkSp x ns

appSp : Sp Γ A (B ⇒ C) → Nf Γ B → Sp Γ A C
appSp ε n = n , ε
appSp (t , ts) n = t , appSp ts n
\end{code}

The full normalization process involves defining term weakening, heterogeneous equality of variables, spine extension, and other related constructions. For brevity, we omit large portions of the code and focus only on illustrating the key components.

A variable is normalized by performing \eta-expansion to the fullest extent possible:

\begin{code}
mutual
  nvar : Var Γ A → Nf Γ A
  nvar x = ne2nf (x , ε)

  ne2nf : Ne Γ A → Nf Γ A
  ne2nf {A = *} e = ne e
  ne2nf {A = A ⇒ B} (v , ns) =
    lam (ne2nf {A = B} (vs v , appSp (wkSp vz ns) (nvar vz)))
\end{code}

Term applications are much more involved, where it is the actual hereditary substitutions happening. To do this, we need to define how to substitute variables inside normal forms and spines, and how to fold a spine on a normal form. The normal form application function \texttt{napp} is defined to launch the substitution process:

\begin{code}[hide]
mutual
  _[_:=_] : Nf Γ B → (x : Var Γ A) → Nf (Γ - x) A → Nf (Γ - x) B
  lam t [ x := u ] = lam (t [ vs x := wkNf vz u ])
  ne (y , ts) [ x := u ] with eq x y
  ... | same = u ◇ (ts < x := u >)
  ... | diff .x y' = ne (y' , (ts < x := u >))

  _<_:=_> : Sp Γ B C → (x : Var Γ A) → Nf (Γ - x) A → Sp (Γ - x) B C
  ε < x := u > = ε
  (t , ts) < x := u > = (t [ x := u ]) , (ts < x := u >)

  _◇_ : Nf Γ A → Sp Γ A B → Nf Γ B
  t ◇ ε = t
  t ◇ (u , us) = napp t u ◇ us
\end{code}

\begin{code}
  napp : Nf Γ (A ⇒ B) → Nf Γ A → Nf Γ B
  napp (lam t) u = t [ vz := u ]
\end{code}

Finally, we have the normalization function from \lambda-terms to normal forms:

\begin{code}
nf : Tm Γ A → Nf Γ A
nf (var x) = nvar x
nf (lam x) = lam (nf x)
nf (app t u) = napp (nf t) (nf u)
\end{code}

\section{Questions}

\subsection{Bush}

\begin{code}
record Bush (X : Type) : Type where
  coinductive
  field
    head : X
    tail : Bush (Bush X)
open Bush
\end{code}

How do we represent \AgdaRecord{Bush­} \AgdaBound{X} as a M type? It turns out that previews scheme is no longer applicable. To address the issue, the key observation is to lift the space from \texttt{Set} to \texttt{Set → Set}. We can show \AgdaRecord{Bush} is the ``higher'' terminal coalgebra of a ``higher'' endofunctor:

\begin{code}
H : (Type → Type) → Type → Type
H F X = X × F (F X)
\end{code}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\AgdaBound{F} \arrow[r, "\AgdaFunction{unfold }\AgdaBound{α⁻}"] \arrow[d, "\AgdaBound{α⁻}"]
& \AgdaRecord{Bush} \arrow[d, "\AgdaFunction{< }\AgdaField{head }\AgdaFunction{, }\AgdaField{tail }\AgdaFunction{>}"] \\
\AgdaFunction{H }\AgdaBound{F} \arrow[r, "\AgdaDatatype{H₁ }\AgdaSymbol{(}\AgdaFunction{unfold }\AgdaBound{α⁻}\AgdaSymbol{)}"]
& \AgdaFunction{H }\AgdaRecord{Bush}
\end{tikzcd}
\]