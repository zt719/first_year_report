\chapter{Conducted Research}

\begin{code}[hide]
{-# OPTIONS --guardedness #-}

open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Product
open import Function.Base
open import Relation.Binary.PropositionalEquality

Type : Set₁
Type = Set

Type₁ : Set₂
Type₁ = Set₁

variable X Y I : Type
\end{code}

In this section, we begin by reviewing related literatures. We then introduce a categorical semantics of types, containers, W and M types, categories with families. Finally, we outline the current challenges in this study.

\section{Literature Review}

\subsubsection*{Denotational Semantics of Inductive Types}

From a categorical point of view, inductive types are understood as the initial algebras of functors, which the result was carried out by (Goguen, Thatcher, Wagner and Wright 1977)\cite{goguen1977initial}. Later, the W type as an encoding of strictly positive inductive types was explored by (Dybjer 1997)\cite{dybjer1997representing}. It was proved that every strictly positive endofunctor on the category of sets generated by Martin-Löf's extensional type theory has an initial algebra.

\subsubsection*{Containers}

(Abbott, Altenkirch and Ghani 2003)\cite{abbott2003categories} presented the categories of containers and showed some nice closure properties. This work could be used to redefine W type and therefore serve as an alternative semantics of strictly positive types. Later, in (Abbott, Altenkirch and Ghani 2005)\cite{abbott2005containers}, the n-ary containers were introduced to capture data types with arguments such as lists and trees. And in (Altenkirch and Ghani 2015), the indexed containers were studied to cover inductive type families such as vectors. They also showed that indexed W type can be converted into normal W type. Some related formalization has been done in Cubical Agda in (Damato, Altenkirch and Ljungström 2024)\cite{damato2024formalising}.

\subsubsection*{Higher-Order Data Types}

In (Johann and Polonsky 2019)\cite{johann2019higher}, they presented the syntax of semantics of higher-order data types.

\subsubsection*{This work}

The object of this project is to review this categorical semantics of higher-order data types. We formalize the syntax and semantics in Agda. We also ``containerize'' the definition to provide the semantics higher-order strict positivity.

\section{Types as Algebras}

\subsection{Inductive Types as Initial Algebras}

\subsubsection*{Natural Number}

Natural number {$\mathbb{N}$ := {0, 1, 2, 3, ...} can be defined inductively:

\begin{code}
data ℕ : Type where
  vz : ℕ
  vs : ℕ → ℕ
\end{code}

\subsubsection*{Categories of Algebras}

Given an endofunctor $F : \textbf{Set} \to \textbf{Set}$, an algebra is defined as a carrier type $A : Set$ and an evaluation function $\alpha : F\;A \to A$. The morphisms between algebras $(A,\alpha)$ and $(B,\beta)$ are given by a function $f : A \to B$ such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  F\;A \arrow[r, "F\;f"] \arrow[d, "\alpha"]
  & F\;B \arrow[d, "\beta"] \\
  A \arrow[r, "f"]
  & B
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the maybe functor. We write this as $\mathbb{N} \cong \mu X. 1 + X$.

To prove this result, we first massage its constructors into an equivalent function form:

\begin{code}
[z,s] : ⊤ ⊎ ℕ → ℕ
[z,s] (inj₁ tt) = vz
[z,s] (inj₂ n) = vs n
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding function:

\begin{code}
fold : (⊤ ⊎ X → X) → ℕ → X
fold α vz = α (inj₁ tt)
fold α (vs n) = α (inj₂ (fold α n))
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5cm]
1 + \mathbb{N} \arrow[r, "1 + fold\;\alpha"] \arrow[d, "{[z,s]}"]
& 1 + X \arrow[d, "\alpha"] \\
\mathbb{N} \arrow[r, "fold\;\alpha"]
& X
\end{tikzcd}
\]


\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. We therefore dualize the concept of natural number. The conatural number is the terminal coalgebra of the maybe functor, we write this as $\mathbb{N}\infty \cong \nu X. 1 + X$. In Agda, conatural number is defined as coinductive type:

\subsubsection*{Conatural Number}

\begin{code}
record ℕ∞ : Type where
  coinductive
  field
    pred∞ : ⊤ ⊎ ℕ∞
open ℕ∞
\end{code}

To complete the diagram, we also define the inverse of folding, which is called unfolding:

\begin{code}
unfold : (X → ⊤ ⊎ X) → X → ℕ∞
pred∞ (unfold α⁻ x) with α⁻ x 
... | inj₁ tt = inj₁ tt
... | inj₂ x' = inj₂ (unfold α⁻ x')
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& \mathbb{N}\infty \arrow[d, "pred\infty"] \\
1 + X \arrow[r, "1 + unfold\;\alpha^{-}"]
& 1 + \mathbb{N}\infty
\end{tikzcd}
\]

\section{Containers}

\subsection{Strict Positivity}

Containers are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}
{-# NO_POSITIVITY_CHECK #-}
data Weird : Type where
  foo : (Weird → ⊥) → Weird
\end{code}

The type \texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Violating strict positivity can lead to issues such as non-normalizability, non-termination, inconsistency and so on. In this weird case, it becomes possible to construct a empty type term, which contradicts to the empty definition:

\begin{code}
¬weird : Weird → ⊥
¬weird (foo x) = x (foo x)

empty : ⊥
empty = ¬weird (foo ¬weird)
\end{code}

\subsection{Syntax and Semantics}

An unary container is given by a type of shapes \textit{S} and a type family indexed by \textit{S},called positions \textit{P}:

\begin{code}
record Cont : Type₁ where
  constructor _◃_
  field
    S : Type
    P : S → Type
\end{code}

\begin{code}[hide]
variable SP TQ SP' TQ' CV : Cont
\end{code}

The morphisms of unary containers are defined as a function which maps shapes and a family of (backward) functions that map positions indexed by $S$.

\begin{code}
record ContHom (SP TQ : Cont) : Type where
  constructor _◃_
  open Cont SP
  open Cont TQ renaming (S to T; P to Q)
  field
    f : S → T
    g : (s : S) → Q (f s) → P s
\end{code}

\begin{code}[hide]
variable fg hk : ContHom SP TQ
\end{code}

such that the identity morphisms and compositions exist.

\begin{code}
idContHom : ContHom SP SP
idContHom = id ◃ λ s → id

_∘ContHom_ : ContHom TQ CV → ContHom SP TQ → ContHom SP CV
(f ◃ g) ∘ContHom (h ◃ k) = (f ∘ h) ◃ λ s → k s ∘ g (h s)
\end{code}

Therefore, they form a category \textbf{CONT}.

\subsubsection*{Extension Functor}

An unary container gives rise to a functor $\textbf{Set} \to \textbf{Set}$ along the container extension functor $\llbracket\_\rrbracket$. We denote the mapping objects of a functor with no subscript or $_0$ as it maps 0-cell, and mapping morphisms part with $_1$ as it maps 1-cell.

\begin{code}
record ⟦_⟧ (SP : Cont) (X : Type) : Type where
  constructor _,_
  open Cont SP
  field
    s : S
    k : P s → X

⟦_⟧₁ : (SP : Cont) → (X → Y) → ⟦ SP ⟧ X → ⟦ SP ⟧ Y
⟦ SP ⟧₁ f (s , k) = s , f ∘ k
\end{code}

As containers give rise to functors, the morphisms of containers naturally give rise to the morphisms of functors - the natural transformations:

\begin{code}
⟦_⟧Hom : ContHom SP TQ → (X : Type) → ⟦ SP ⟧ X → ⟦ TQ ⟧ X
⟦ f ◃ g ⟧Hom X (s , k) = f s , k ∘ g s
\end{code}

We show that the extension functor is fully faithful by constructing a bijection between $S \triangleleft P \to T \triangleleft Q$ and $\llbracket S \triangleleft P \rrbracket \to \llbracket T \triangleleft Q \rrbracket$

\begin{align*}
& S \triangleleft P \rightarrow_{Cont} T \triangleleft Q \\
&= \sum_{f : S \to T} \prod_{s : S} Q \; (f \; s) \to P \; s && \text{definition of $\rightarrow_{Cont}$} \\
&\cong \prod_{s : S} \sum_{t : T} Q \; t \to P \; s && \text{type theoretical choice} \\
&= \prod_{s : S} \llbracket T \triangleleft Q \rrbracket (P \; s) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \prod_{s : S} \int_{X : Set} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{covariant Yoneda lemma} \\
&\cong \int_{X : Set} \prod_{s : S} ((P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{commutative of $\int$ and $\prod$} \\
&\cong \int_{X : Set} (\sum_{s : S} (P \; s \to X) \to \llbracket T \triangleleft Q \rrbracket X) && \text{uncurry} \\
&= \int_{X : Set} \llbracket S \triangleleft P \rrbracket X \to \llbracket T \triangleleft Q \rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, vz, multiplication and addition for containers:

\begin{code}
⊤C : Cont
⊤C = ⊤ ◃ const ⊥

⊥C : Cont
⊥C = ⊥ ◃ ⊥-elim

_×C_ : Cont → Cont → Cont
(S ◃ P) ×C (T ◃ Q) = (S × T) ◃ λ (s , t) → P s ⊎ Q t

_⊎C_ : Cont → Cont → Cont
(S ◃ P) ⊎C (T ◃ Q) = (S ⊎ T) ◃ λ{ (inj₁ s) → P s ; (inj₂ t) → Q t }
\end{code}

such that the semiring laws should hold. Both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. We use \texttt{⊥}, \texttt{⊤}, \texttt{×} and \texttt{⊎} as they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers. In fact, the category of containers has all finite products and coproducts. We give the definitions and show that they are both preserved by the extension functor.

\subsubsection*{Products}

\begin{code}
ΠC : (I → Cont) → Cont
ΠC {I} SPs = ((i : I) → SPs i .Cont.S) ◃ λ f → Σ[ i ∈ I ] SPs i .Cont.P (f i)
\end{code}

\begin{align*}
& \prod_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \prod_{i : I} \sum_{s : S_i} (P_i \; s \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{f : \prod_{i : I} S_i} \prod_{i : I} (P_i \; (f \; i) \to X) && \text{type theoretical choice} \\
&\cong \sum_{f : \prod_{i : I} S_i} \left( \sum_{i : I} P_i \; (f \; i) \to X \right) && \text{uncurry} \\
&= \left\llbracket f : \prod_{i : I} S_i \triangleleft \sum_{i : I} P_i \; (f \; i) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Coproducts}

\begin{code}
ΣC : (I → Cont) → Cont
ΣC {I} SPs = (Σ[ i ∈ I ] SPs i .Cont.S) ◃ λ (i , s) → SPs i .Cont.P s
\end{code}

\begin{align*}
& \sum_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \sum_{i : I} \sum_{s_i : S_i} (P_i \; s_i \to X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{(i , s_i) : \sum_{i : I} S_i} (P_i \; s_i \to X) && \text{associative of $\sum$} \\
&= \left\llbracket (i , s_i) : \sum_{i : I} S_i \triangleleft P_i \; s_i \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Compositions}

We can also define compositions of unary containers. This composition should reflect the process of consecutively applying container functors.

\begin{code}
_∘C_ : Cont → Cont → Cont
(S ◃ P) ∘C (T ◃ Q) = (Σ[ s ∈ S ] (P s → T)) ◃ λ (s , f) → Σ[ p ∈ P s ] Q (f p)
\end{code}

\begin{align*}
& \llbracket S \triangleleft P \rrbracket (\llbracket T \triangleleft Q \rrbracket X) \\
&= \sum_{s : S} \left( P \; s \to \sum_{t : T} (Q \; t \to X) \right) && \text{ definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{s : S} \sum_{f : P \: s \to T} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{type theoretical choice} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \prod_{p : P \: s} (Q \; (f \; p) \to X) && \text{associative of $\sum$} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \left( \sum_{p : P \: s} Q \; (f \; p) \to X \right) && \text{uncurry} \\
&= \left\llbracket \sum_{(s , f) : \sum_{s : S} ( P \: s \to T )} \triangleleft \sum_{p : P \: s} Q \; (f \; p) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{2-Categorical Structures}

\textbf{Cont} has 2-categorical structures as the extension functor leads to the functor category. The vertical composition is just \AgdaFunction{\_∘ContHom\_}. We define the horizontal compositions (tensor products) of morphisms, which also corresponds to the functoriality of \AgdaFunction{\_∘C\_}

\subsubsection*{Horizontal Compositions}

\begin{code}
_⊗ContHom_ : ContHom SP TQ → ContHom SP' TQ' → ContHom (SP ∘C SP') (TQ ∘C TQ')
(f ◃ g) ⊗ContHom (f' ◃ g') 
  = (λ{ (s , k) → f s , f' ∘ k ∘ g s }) 
  ◃ λ{ (s , k) (q' , h) → g s q' , g' (k (g s q')) h }
\end{code}

such that the identity and compositions (interchanged law) are preserved. The proof is immediate by checking cases.

TODO : I need a diagram here

\subsection{W and M}

We now present the general form of inductive types, which is the W type. The standard notion of W in the HoTT book is given by $A : Type$ and $B : A \to Type$, which is written as $W_{a : A} B (a)$. It is equipped with a single constructor $sup : \prod_{a : A} (B (a) \to W_{x : A} B (x)) \to W_{x : A} B (x)$. Notice that this definition is equivalent to the following container definition:

\begin{code}
data W (SP : Cont) : Type where
  sup : ⟦ SP ⟧ (W SP) → W SP
\end{code}

This definition implies that any inductive type can be characterized by a container functor algebra. Indeed, we can retrieve an equivalent definition of natural number through the maybe container.

\begin{code}
⊤⊎Cont : Cont
⊤⊎Cont = (⊤ ⊎ ⊤) ◃ λ{ (inj₁ tt) → ⊥ ; (inj₂ y) → ⊤ }

ℕ' : Type
ℕ' = W ⊤⊎Cont
\end{code}

Dually, the general form of coinductive types - M type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}
record M (SP : Cont) : Type where
  coinductive
  field
    inf : ⟦ SP ⟧ (M SP)
open M

ℕ∞' : Type
ℕ∞' = M ⊤⊎Cont
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\llbracket SP \rrbracket (W\;SP) \arrow[r, "\llbracket SP \rrbracket (fold\;\alpha)"] \arrow[d, "sup"]
& \llbracket SP \rrbracket X \arrow[d, "\alpha"] \\
W\;SP \arrow[r, "(fold\;\alpha)"]
& X
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
X \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& M\;SP \arrow[d, "inf"] \\
\llbracket SP \rrbracket X \arrow[r, "\llbracket SP \rrbracket (unfold\;\alpha^{-})"]
& \llbracket SP \rrbracket (M\;SP)
\end{tikzcd}
\]

As a conclusion, W and M are essentially \mu and \nu:

\[ W(S \triangleleft P) \cong \mu X. \llbracket S \triangleleft P \rrbracket X \]
\[ M(S \triangleleft P) \cong \nu X. \llbracket S \triangleleft P \rrbracket X \]

\section{Categories with Families}

The Categories with Families (CwFs) are categorical framework for interpreting dependent type theory. They model core concepts like context formation, substitution, weakening, etc. However, CwFs are more related to an alternative type theory - a substitution calculus by Martin-Löf, in which the substitution is first class and explicitly formulated.

\subsection{General Definition}

There are many equivalent ways to define CwFs, we only present one definition which is suitable for our formalization. A CwF is given by:

\begin{itemize}
  \item{A category \textbf{C}. Its objects is a set of contexts, denoted by \Gamma, \Delta, etc, Its morphisms is a set of context substitutions, denoted by \gamma, \delta, etc. We call the objects type $Con$ and morphisms type $Tms$ (or $Subst$).
  
  Categorical rules for \textbf{C}:

  \begin{align*}
    id_{\Gamma} \circ \gamma & = \gamma \\
    \gamma \circ id_{\Gamma} & = \gamma \\
    (\gamma \circ \delta) \circ \theta & = \gamma \circ (\delta \circ \theta) \\
  \end{align*}
  }

  \item{A terminal object $\bullet : Con$ which represents the empty context, with the terminal map $\epsilon_{\Gamma} : Tms\;\Gamma\;\bullet$ which represents the empty substitution. 
  
  Universal property of $\bullet$:

  \begin{align*}
    \epsilon_{\Gamma} \circ \gamma & = \epsilon_{\Gamma} \\
    id_{\bullet} & = \epsilon_{\bullet} \\
  \end{align*}
  }

  \item{A presheaf $Ty : \textbf{C}^{op} \to \textbf{Set}$ which represents a set of types of a given context $\Gamma$. We use A, B, etc. to denote type. For each $\gamma : Tms (\Delta, \Gamma)$, we also define a special syntax $\_[\gamma] : Ty(\Gamma) \to Ty(\Delta)$ for the mapping morphisms part of $Ty$.

  Functoriality of $Ty$:

  \begin{align*}
    A [id_{\Gamma}] & = A \\
    A [\gamma \circ \delta] & = A [\gamma] [\delta] \\
  \end{align*}
  }

  \item{A presheaf 
  $Tm : (\int_{\textbf{C}})^{op} \to \textbf{Set}$ 
  which represents a set of terms of a given type $Ty(\Gamma)$. We use a, b, etc. to denote terms. For each $\gamma : Tms (\Delta, \Gamma)$ and $A : Ty(\Gamma)$, we also define a special syntax $\_[\gamma] : Tm(\Gamma, A) \to Tm(\Delta, A [\gamma])$ for the mapping morphisms part of $Tm$.

  Functoriality of $Ty$:

  \begin{align*}
    a [id_{\Gamma}] & = a \\
    a [\gamma \circ \delta] & = a [\gamma] [\delta] \\
  \end{align*}
  }

\item{A comprehension operation, which represents the context extensions. For each $\Gamma : Con$ and $A : Ty(\Gamma)$, there is an extended context $\Gamma \triangleright A$. For each $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm (\Delta, A[\gamma])$, there is an extended substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$. For each $\gamma : Tms (\Delta, \Gamma \triangleright A)$, there is a projection from $\gamma$ to $Tms (\Delta, \Gamma)$ that forgets the top variable, denoted by $\pi_1$; and a projection from $\gamma$ to an unique term $a : Tm (\Delta, A[\pi_1 \gamma])$ which essentially is the variable being forgotten, denoted by $\pi_2$.

The comprehension also comes with an universal property that, for every $\gamma : Tms (\Delta, \Gamma)$ and $a : Tm(\Gamma , A[\gamma])$, there exists a unique substitution $(\gamma, a) : Tms (\Delta, \Gamma \triangleright A)$, such that:

  \begin{align*}
    \pi_1\;(\gamma, a) & = \gamma \\
    \pi_2\;(\gamma, a) & = a \\
    (\pi_1\;\gamma , \pi_2\;\gamma) & = \gamma \\
    (\delta, a) \circ \gamma & = (\delta \circ \gamma , a) \\
  \end{align*}
  }
  
\end{itemize}

\subsection{Adding Functions}

The CwF on its own typically does not say anything about types. We can add dependent function types to the framework separately.

For each $\Gamma : Con$, $A : Ty(\Gamma)$ and $B : Ty(\Gamma \triangleright A)$, there exist a dependent function type $\Pi (A, B) : Ty(\Gamma)$. For each $b : Tm(\Gamma \triangleright A, B)$, there is a function $lam(b) : Tm (\Gamma, \Pi (A, B))$. Inversely, for each $f : Tm(\Gamma, \Pi (A, B))$, there is a term $app(f) : Tm(\Gamma \triangleright A, B)$.

Rules for $lam$ and $app$, which are essentially \beta-rule and \eta-rule:

\begin{align*}
  app (lam (a)) & = a \\
  lam (app (f)) & = f \\
\end{align*}

In order to define the substitutions under $\Pi$, $lam$ and $app$, we need to first construct context substitution lifting operation: for each $\gamma : Tms (\Delta, \Gamma)$, it can be lifted to $\gamma \uparrow : Tms (\Delta \triangleright A [\gamma], \Gamma \triangleright A)$ by arbitrary $A : Ty(\Gamma)$.

Rules for substitution lifting and functions under substitutions.

\begin{align*}
  \gamma \uparrow & = \gamma \circ (\pi_1\;id) , \pi_2\;id \\
  (\Pi(A,B)) [\gamma] &= \Pi (A [\gamma], B [\gamma \uparrow]) \\
  (lam (a)) [\gamma] &= lam (t [\gamma \uparrow]) \\
  (app (f)) [\gamma \uparrow] &= app (f [\gamma]) \\
\end{align*}

\subsection{Simply Typed Categories with Families}

For the purposes of our research, we are primarily interested in a weaker variant of CwF, namely the simply typed CwF $(SCwF)$. The essence of a SCwF is to capture precisely the model of the simply typed \lambda-calculus, where types are independent of context. Therefore, while context substitution is still required for terms, it is not needed for types.

The model can be derived by constraining $Ty$ to be a constant presheaf. That is:

\begin{align*}
  & Ty : \lvert\textbf{C}\rvert^{op} \to \textbf{Set} \\
  & Ty(\Gamma) := STy \\
  & Ty(\gamma) := id \\
\end{align*}

where $STy$ should be a set of simple types.

\section{Normalization by Hereditary Substitutions}


A variable is normalized by performing \eta-expansion to the fullest extent possible, defined by a function \AgdaFunction{nvar}. For example, a variable with type $(* \to *) \to * \to *$:

\[ H \rightarrow_{\eta} \lambda F. H\;F \rightarrow_{\eta} \lambda X. \lambda F. H\;F\;X \]

The application case is more involved, where it is the actual hereditary substitutions happening. The substitutions under normal forms are mutually defined with substitutions under neutral terms and spines. The \AgdaFunction{napp} launches the whole process by substitutes the top variable of first term by the second term.

Finally, we obtain the normalization function that \beta-reduces and \eta-expands simply typed terms.

It is proved that the normalizer is complete and sound, but we should omit the proofs here.

\section{Questions}

\subsection{Bush}

\begin{code}
record Bush (X : Type) : Type where
  coinductive
  field
    head : X
    tail : Bush (Bush X)
open Bush
\end{code}

How do we represent $Bush\;X$ as a M type? It turns out that previews scheme is no longer applicable. To address the issue, the key is to lift the space from $Set$ to $Set \to Set$. We can show $Bush$ on its own is the ``higher'' terminal coalgebra of a ``higher'' endofunctor $H$, where it is defined as:

\begin{align*}
& H : (Set \to Set) \to Set \to Set \\
& H (F) (X) = X \times F (F (X)) \\
\end{align*}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
F \arrow[r, "unfold\;\alpha^{-}"] \arrow[d, "\alpha^{-}"]
& Bush \arrow[d, "{<head,tail>}"] \\
H\;F \arrow[r, "H\;(unfold\;\alpha^{-})"]
& H\;Bush
\end{tikzcd}
\]