\chapter{Conducted Research}

\begin{code}[hide]
{-# OPTIONS --guardedness #-}

open import Data.Empty
open import Data.Unit
open import Data.Sum
open import Data.Product
open import Function.Base
open import Relation.Binary.PropositionalEquality

Type : Set₁
Type = Set

Type₁ : Set₂
Type₁ = Set₁

variable X Y I : Type
\end{code}

In this section, we begin by reviewing related literature. We then introduce a categorical semantics of types, containers, W and M types. To facilitate later definition and result of higher containers in the research outcomes section, we also present related topics including categories with families, and normalization by hereditary substitutions. Finally, we outline the current challenges in this area.

\section{Literature Review}
TODO

\section{Types as Algebras}

\subsection{Inductive Types as Initial Algebras}

\subsubsection*{Natural Number}

Natural number \texttt{ℕ = \{0, 1, 2, 3, ...\}} can be defined inductively:

\begin{code}
data ℕ : Type where
  zero : ℕ
  suc : ℕ → ℕ
\end{code}

\subsubsection*{Categories of Algebras}

Given an endofunctor \texttt{F : Type → Type}, an algebra is defined as a carrier type \texttt{A : Type} and an evaluation function \texttt{α : F A → A}. The morphisms between algebras \texttt{(A ,  α)} and \texttt{(B , β)} are given by a function \texttt{f : A → B} such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=huge]
  \texttt{F A} \arrow[r, "\texttt{F f}"] \arrow[d, "\texttt{α}"]
  & \texttt{F B} \arrow[d, "\texttt{β}"] \\
  \texttt{A} \arrow[r, "\texttt{f}"]
  & \texttt{B}
\end{tikzcd}
\]

Natural number (with its constructors) is the initial algebra of the maybe functor. We write this as

\[ \texttt{ℕ ≅ μ X. ⊤ ⊎ X} \]

To prove this, we first massage its constructors into an equivalent function form:

\begin{code}
[z,s] : ⊤ ⊎ ℕ → ℕ
[z,s] (inj₁ tt) = zero
[z,s] (inj₂ n) = suc n
\end{code}

For the initiality, we show for any algebra there exists a unique morphism form algebra \texttt{ℕ}. That is to first undefine folding function:

\begin{code}
fold : (⊤ ⊎ X → X) → ℕ → X
fold α zero = α (inj₁ tt)
fold α (suc n) = α (inj₂ (fold α n))
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{⊤ ⊎ ℕ} \arrow[r, "\texttt{⊤ ⊎ (fold α)}"] \arrow[d, "\texttt{[z,s]}"]
& \texttt{⊤ ⊎ X} \arrow[d, "\texttt{α}"] \\
\texttt{ℕ} \arrow[r, "\texttt{fold α}"]
& \texttt{X}
\end{tikzcd}
\]

\subsection{Coinductive Types as Terminal Coalgebras}

One of the greatest power of category theory is that the opposite version of a theorem can always be derived for free. We dualize above diagram, defining conatural number as coinductive type and the inverse of folding function, the unfolding:

\subsubsection*{Conatural Number}

\begin{code}
record ℕ∞ : Type where
  coinductive
  field
    pred∞ : ⊤ ⊎ ℕ∞
open ℕ∞

unfold : (X → ⊤ ⊎ X) → X → ℕ∞
pred∞ (unfold α⁻ x) with α⁻ x 
... | inj₁ tt = inj₁ tt
... | inj₂ x' = inj₂ (unfold α⁻ x')
\end{code}

such that the following diagram commutes:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{X} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{ℕ∞} \arrow[d, "\texttt{pred∞}"] \\
\texttt{⊤ ⊎ X} \arrow[r, "\texttt{⊤ ⊎ (unfold α⁻)}"]
& \texttt{⊤ ⊎ ℕ∞}
\end{tikzcd}
\]

Therefore conatural number is the terminal coalgebra of the same signature functor.

\[ \texttt{ℕ∞ ≅ ν X. ⊤ ⊎ X} \]

\section{Containers}

\subsection{Strict Positivity}

Containers\cite{ABBOTT20053} are categorical and type-theoretical abstraction to describe strictly positive datatypes. A strictly positive type is the type where all data constructors do not include itself on the left-side of a function arrow. Here is a counterexample:

\subsubsection*{Weird}

\begin{code}
{-# NO_POSITIVITY_CHECK #-}
data Weird : Type where
  foo : (Weird → ⊥) → Weird
\end{code}

The type \texttt{Weird} is not strictly positive, as itself appears on the left-side of \texttt{→} in \texttt{foo}. Violating strict positivity can lead to issues such as non-normalizability, non-termination, inconsistency and so on. In this weird case, it becomes possible to construct a empty type term, which contradicts to the empty definition:

\begin{code}
¬weird : Weird → ⊥
¬weird (foo x) = x (foo x)

empty : ⊥
empty = ¬weird (foo ¬weird)
\end{code}

\subsection{Syntax and Semantics}

An unary container is given by a type of shapes \texttt{S} and a type family indexed by \texttt{S},called positions \texttt{P}:

\begin{code}
record Cont : Type₁ where
  constructor _◃_
  field
    S : Type
    P : S → Type
\end{code}

\begin{code}[hide]
variable SP TQ SP' TQ' CV : Cont
\end{code}

The morphisms of unary containers are defined as a function which maps shapes and a family of (backward) functions that map positions indexed by \texttt{S}.

\begin{code}
record ContHom (SP TQ : Cont) : Type where
  constructor _◃_
  open Cont SP
  open Cont TQ renaming (S to T; P to Q)
  field
    f : S → T
    g : (s : S) → Q (f s) → P s
\end{code}

\begin{code}[hide]
variable fg hk : ContHom SP TQ
\end{code}

such that the identity morphisms \texttt{idContHom} and compositions \texttt{\_∘ContHom\_} exist.

\begin{code}
idContHom : ContHom SP SP
idContHom = id ◃ λ s → id

_∘ContHom_ : ContHom TQ CV → ContHom SP TQ → ContHom SP CV
(f ◃ g) ∘ContHom (h ◃ k) = (f ∘ h) ◃ λ s → k s ∘ g (h s)
\end{code}

Therefore, the containers form a category \textbf{Cont}.

\subsubsection*{Extension Functor}

An unary container gives rise to a endofunctor of \texttt{Set} along the container extension functor \texttt{⟦\_⟧}. We explicitly distinguish mapping objects and mapping morphisms part of a functor.

\begin{code}
record ⟦_⟧ (SP : Cont) (X : Type) : Type where
  constructor _,_
  open Cont SP
  field
    s : S
    k : P s → X

⟦_⟧₁ : (SP : Cont) → (X → Y) → ⟦ SP ⟧ X → ⟦ SP ⟧ Y
⟦ SP ⟧₁ f (s , k) = s , f ∘ k
\end{code}

As containers give rise to functors, naturally, the morphisms of containers give rise to the morphisms of functors - the natural transformations:

\begin{code}
⟦_⟧Hom : ContHom SP TQ → (X : Type) → ⟦ SP ⟧ X → ⟦ TQ ⟧ X
⟦ f ◃ g ⟧Hom X (s , k) = f s , k ∘ g s
\end{code}

We show that the extension functor is fully faithful by constructing a bijection between \texttt{ContHom (S ◃ P) (T ◃ Q)} and \texttt{NatTrans ⟦ S ◃ P ⟧ ⟦ T ◃ Q ⟧}

\begin{align*}
& S \triangleleft P \rightarrow_{Cont} T \triangleleft Q \\
&= \sum_{f : S \rightarrow T} \prod_{s : S} Q \; (f \; s) \rightarrow P \; s && \text{definition of $\rightarrow_{Cont}$} \\
&\cong \prod_{s : S} \sum_{t : T} Q \; t \rightarrow P \; s && \text{type theoretical choice} \\
&= \prod_{s : S} \llbracket T \triangleleft Q \rrbracket (P \; s) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \prod_{s : S} \int_{X : Set} ((P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{covariant Yoneda lemma} \\
&\cong \int_{X : Set} \prod_{s : S} ((P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{commutative of $\int$ and $\prod$} \\
&\cong \int_{X : Set} (\sum_{s : S} (P \; s \rightarrow X) \rightarrow \llbracket T \triangleleft Q \rrbracket X) && \text{uncurry} \\
&= \int_{X : Set} \llbracket S \triangleleft P \rrbracket X \rightarrow \llbracket T \triangleleft Q \rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{Algebraic Structures}

Containers are also known as polynomial functors as they exhibit a semiring structure. Namely, we can define one, zero, multiplication and addition for containers:

\begin{code}
⊤C : Cont
⊤C = ⊤ ◃ const ⊥

⊥C : Cont
⊥C = ⊥ ◃ ⊥-elim

_×C_ : Cont → Cont → Cont
(S ◃ P) ×C (T ◃ Q) = (S × T) ◃ λ (s , t) → P s ⊎ Q t

_⊎C_ : Cont → Cont → Cont
(S ◃ P) ⊎C (T ◃ Q) = (S ⊎ T) ◃ λ{ (inj₁ s) → P s ; (inj₂ t) → Q t }
\end{code}

such that the semiring laws should hold. Both multiplication and addition are commutative, associative, and each is left- and right-annihilated by its corresponding unit. We use \texttt{⊥}, \texttt{⊤}, \texttt{×} and \texttt{⊎} as they correspond precisely to the initial object, terminal object, product and coproduct within the category of containers. In fact, the category of containers has all finite products and coproducts. We give the definitions and show that they are both preserved by the extension functor.

\subsubsection*{Products}

\begin{code}
ΠC : (I → Cont) → Cont
ΠC {I} SPs = ((i : I) → SPs i .Cont.S) ◃ λ f → Σ[ i ∈ I ] SPs i .Cont.P (f i)
\end{code}

\begin{align*}
& \prod_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \prod_{i : I} \sum_{s : S_i} (P_i \; s \rightarrow X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{f : \prod_{i : I} S_i} \prod_{i : I} (P_i \; (f \; i) \rightarrow X) && \text{type theoretical choice} \\
&\cong \sum_{f : \prod_{i : I} S_i} \left( \sum_{i : I} P_i \; (f \; i) \rightarrow X \right) && \text{uncurry} \\
&= \left\llbracket f : \prod_{i : I} S_i \triangleleft \sum_{i : I} P_i \; (f \; i) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Coproducts}

\begin{code}
ΣC : (I → Cont) → Cont
ΣC {I} SPs = (Σ[ i ∈ I ] SPs i .Cont.S) ◃ λ (i , s) → SPs i .Cont.P s
\end{code}

\begin{align*}
& \sum_{i : I} (\llbracket S_i \triangleleft P_i \rrbracket X) \\
&= \sum_{i : I} \sum_{s : S_i} (P_i \; s \rightarrow X) && \text{definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{(i , s_i) : \sum_{i : I} S_i} (P_i \; s_i \rightarrow X) && \text{associative of $\sum$} \\
&= \left\llbracket (i , s_i) : \sum_{i : I} S_i \triangleleft P_i \; s_i \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsubsection*{Composition}

We can also define composition of unary containers. This composition should reflect consecutively applying container functors.

\begin{code}
_∘C_ : Cont → Cont → Cont
(S ◃ P) ∘C (T ◃ Q) = (Σ[ s ∈ S ] (P s → T)) ◃ λ (s , f) → Σ[ p ∈ P s ] Q (f p)
\end{code}

\begin{align*}
& \llbracket S \triangleleft P \rrbracket (\llbracket T \triangleleft Q \rrbracket X) \\
&= \sum_{s : S} \left( P \; s \rightarrow \sum_{t : T} (Q \; t \rightarrow X) \right) && \text{ definition of $\llbracket \_ \rrbracket$} \\
&\cong \sum_{s : S} \sum_{f : P \: s \rightarrow T} \prod_{p : P \: s} (Q \; (f \; p) \rightarrow X) && \text{type theoretical choice} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \prod_{p : P \: s} (Q \; (f \; p) \rightarrow X) && \text{associative of $\sum$} \\
&\cong \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \left( \sum_{p : P \: s} Q \; (f \; p) \rightarrow X \right) && \text{uncurry} \\
&= \left\llbracket \sum_{(s , f) : \sum_{s : S} ( P \: s \rightarrow T )} \triangleleft \sum_{p : P \: s} Q \; (f \; p) \right\rrbracket X && \text{definition of $\llbracket \_ \rrbracket$} \\
\end{align*}

\subsection{2-Categorical Structures}

\textbf{Cont} has 2-categorical structures as the extension functor leads to the functor category. The vertical composition is just \texttt{\_∘ContHom\_}. We define the horizontal compositions (tensor products) of morphisms, which also corresponds to the functoriality of \texttt{\_∘C\_}

\subsubsection*{Horizontal Compositions}

\begin{code}
_⊗ContHom_ : ContHom SP TQ → ContHom SP' TQ' → ContHom (SP ∘C SP') (TQ ∘C TQ')
(f ◃ g) ⊗ContHom (f' ◃ g') 
  = (λ{ (s , k) → f s , f' ∘ k ∘ g s }) 
  ◃ λ{ (s , k) (q' , h) → g s q' , g' (k (g s q')) h }
\end{code}

such that the identity and compositions (interchanged law) are preserved. The proof is immediate by checking cases.

TODO : I need a diagram here

\subsection{W and M}

We now present the general form of inductive types, which is the W type:

\begin{code}
data W (SP : Cont) : Type where
  sup : ⟦ SP ⟧ (W SP) → W SP
\end{code}

This definition implies that any inductive type can be characterized by a container algebra. Indeed, we can retrieve an equivalent definition of natural number through the maybe container.

\begin{code}
⊤⊎Cont : Cont
⊤⊎Cont = (⊤ ⊎ ⊤) ◃ λ{ (inj₁ tt) → ⊥ ; (inj₂ y) → ⊤ }

ℕ' : Type
ℕ' = W ⊤⊎Cont
\end{code}

Dually, the general form of coinductive types - M type is just the terminal coalgebra of containers. W and conatural number are defined as follow:

\begin{code}
record M (SP : Cont) : Type where
  coinductive
  field
    inf : ⟦ SP ⟧ (M SP)
open M

ℕ∞' : Type
ℕ∞' = M ⊤⊎Cont
\end{code}

Finally, we obtain the following commutative diagrams for W and M:

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{⟦ SP ⟧ }\texttt{(W SP)} \arrow[r, "\texttt{⟦ SP ⟧ (fold α)}"] \arrow[d, "\texttt{sup}"]
& \texttt{⟦ SP ⟧ X} \arrow[d, "\texttt{α}"] \\
\texttt{W SP} \arrow[r, "\texttt{fold α}"]
& \texttt{X}
\end{tikzcd}
\]

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{X} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{M SP} \arrow[d, "\texttt{inf}"] \\
\texttt{⟦ SP ⟧ X} \arrow[r, "\texttt{⟦ SP ⟧ (unfold α⁻)}"]
& \texttt{⟦ SP ⟧ (M SP)}
\end{tikzcd}
\]

\input{latex/scwfs}

\section{Normalization by Hereditary Substitutions}

We introduce the hereditary substitutions technique for \lambda-calculus normalization. To build the syntax of \lambda-calculus, we first define a simple syntax of types and contexts. We use \texttt{A B C} to range over types and \texttt{Γ Δ Θ} to range over contexts.

\begin{code}
data Ty : Type where
  *   : Ty
  _⇒_ : Ty → Ty → Ty

data Con : Type where
  ∙   : Con
  _▹_ : Con → Ty → Con
\end{code}

\begin{code}[hide]
variable A B C : Ty
variable Γ Δ : Con
\end{code}

\subsubsection*{De Bruijn Indices}

We adopt the De Bruijn indices to capture variables. The idea is to replace the name of variable in context with number, with the innermost (rightmost) variable gets index 0 and outermost (leftmost) variable gets the biggest index. For example \texttt{λx.λy.x} in de bruijn form is \texttt{λ.λ.1}. We use \texttt{x y} to range over variables.

\begin{code}
data Var : Con → Ty → Type where
  vz : Var (Γ ▹ A) A
  vs : Var Γ A → Var (Γ ▹ B) A
\end{code}

\subsubsection*{\lambda-Terms}

The \lambda-terms follows the normal convention, which is either a variable, or a \lambda-abstraction, or a term application.

\begin{code}
data Tm : Con → Ty → Set where
  var : Var Γ A → Tm Γ A
  lam : Tm (Γ ▹ A) B → Tm Γ (A ⇒ B)
  app : Tm Γ (A ⇒ B) → Tm Γ A → Tm Γ B
\end{code}

\begin{code}[hide]
variable x y : Var Γ A
\end{code}

\subsubsection*{Normal Forms}

We also need to define the syntax of normal forms. Normalized \lambda-terms are defined as either: \lambda-abstractions of normal forms; or neutral terms, where neutral terms are variables applied to lists of normal forms, called the spines. The \texttt{Nf}, \texttt{Ne} and \texttt{Sp} are mutually defined in Agda:

\begin{code}
mutual
\end{code}

\begin{code}
  data Nf : Con → Ty → Type where
    lam : Nf (Γ ▹ A) B → Nf Γ (A ⇒ B)
    ne  : Ne Γ * → Nf Γ *

  data Ne : Con → Ty → Type where
    _,_ : Var Γ A → Sp Γ A B → Ne Γ B

  data Sp : Con → Ty → Ty → Type where
    ε   : Sp Γ A A
    _,_ : Nf Γ A → Sp Γ B C → Sp Γ (A ⇒ B) C
\end{code}

\begin{code}[hide]
_-_ : (Γ : Con) → Var Γ A → Con
(Γ ▹ A) - vz = Γ
(Γ ▹ A) - vs x = (Γ - x) ▹ A

wkv : (x : Var Γ A) → Var (Γ - x) B → Var Γ B
wkv vz y = vs y
wkv (vs x) vz = vz
wkv (vs x) (vs y) = vs (wkv x y)

data EqVar : Var Γ A → Var Γ B → Set where
  same : EqVar x x
  diff : (x : Var Γ A) (y : Var (Γ - x) B) → EqVar x (wkv x y)

eq : (x : Var Γ A) (y : Var Γ B) → EqVar x y
eq vz vz = same
eq vz (vs y) = diff vz y
eq (vs x) vz = diff (vs x) vz
eq (vs x) (vs y) with eq x y
... | same = same
... | diff .x y = diff (vs x) (vs y)

mutual
  wkNf : (x : Var Γ A) → Nf (Γ - x) B → Nf Γ B
  wkNf x (lam n) = lam (wkNf (vs x) n)
  wkNf x (ne e) = ne (wkNe x e)

  wkNe : (x : Var Γ A) → Ne (Γ - x) B → Ne Γ B
  wkNe x (v , ns) = wkv x v , wkSp x ns

  wkSp : (x : Var Γ A) → Sp (Γ - x) B C → Sp Γ B C
  wkSp x ε = ε
  wkSp x (n , ns) = wkNf x n , wkSp x ns

appSp : Sp Γ A (B ⇒ C) → Nf Γ B → Sp Γ A C
appSp ε n = n , ε
appSp (t , ts) n = t , appSp ts n
\end{code}

In TODO, it builds a canonical normalizer for \lambda-calculi - \texttt{nf : Tm Γ A → Nf Γ A}. We shall not go through the full normalization process in details, but just illustrating the key components for each case.

A variable is normalized by performing \eta-expansion to the fullest extent possible, defined by \texttt{nvar}. For example, a variable with type \texttt{(* ⇒ *) ⇒ * ⇒ *}:

\[ \texttt{H} \rightarrow \texttt{λF.H F} \rightarrow \texttt{λX.λF.H F X} \]

\begin{code}[hide]
mutual
\end{code}

\begin{code}
  nvar : Var Γ A → Nf Γ A
  nvar x = ne2nf (x , ε)

  ne2nf : Ne Γ A → Nf Γ A
  ne2nf {A = *} e = ne e
  ne2nf {A = A ⇒ B} (v , ns) =
    lam (ne2nf {A = B} (vs v , appSp (wkSp vz ns) (nvar vz)))
\end{code}

The application case is more involved, where it is the actual hereditary substitutions happening. The substitutions under normal forms are recursively defined together with substitutions under neutral terms and spines. Finally, the \texttt{napp} launches the whole process by substitutes the top variable of first term by the second term.

\begin{code}[hide]
mutual
  _[_:=_] : Nf Γ B → (x : Var Γ A) → Nf (Γ - x) A → Nf (Γ - x) B
  lam t [ x := u ] = lam (t [ vs x := wkNf vz u ])
  ne (y , ts) [ x := u ] with eq x y
  ... | same = u ◇ (ts < x := u >)
  ... | diff .x y' = ne (y' , (ts < x := u >))

  _<_:=_> : Sp Γ B C → (x : Var Γ A) → Nf (Γ - x) A → Sp (Γ - x) B C
  ε < x := u > = ε
  (t , ts) < x := u > = (t [ x := u ]) , (ts < x := u >)

  _◇_ : Nf Γ A → Sp Γ A B → Nf Γ B
  t ◇ ε = t
  t ◇ (u , us) = napp t u ◇ us
\end{code}

\begin{code}
  napp : Nf Γ (A ⇒ B) → Nf Γ A → Nf Γ B
  napp (lam t) u = t [ vz := u ]
\end{code}

Finally, we obtain the normalization function that \beta-reduces and \eta-expands simply typed terms.

\begin{code}
nf : Tm Γ A → Nf Γ A
nf (var x) = nvar x
nf (lam x) = lam (nf x)
nf (app t u) = napp (nf t) (nf u)
\end{code}

In TODO, it shows the completeness and soundness of the normalizer. But we omit the proof for simplicity purpose.

\section{Questions}

\subsection{Bush}

\begin{code}
record Bush (X : Type) : Type where
  coinductive
  field
    head : X
    tail : Bush (Bush X)
open Bush
\end{code}

How do we represent \texttt{Bush X} as a M type? It turns out that previews scheme is no longer applicable. To address the issue, the key is to lift the space from \texttt{Set} to \texttt{Set → Set}. We can show \texttt{Bush} is the ``higher'' terminal coalgebra of a ``higher'' endofunctor:

\begin{code}
H : (Type → Type) → Type → Type
H F X = X × F (F X)
\end{code}

\[
\begin{tikzcd}[row sep=huge, column sep=5.0cm]
\texttt{F} \arrow[r, "\texttt{unfold α⁻}"] \arrow[d, "\texttt{α⁻}"]
& \texttt{Bush} \arrow[d, "\texttt{< head , tail >}"] \\
\texttt{H F} \arrow[r, "\texttt{H (unfold α⁻)}"]
& \texttt{H Bush}
\end{tikzcd}
\]