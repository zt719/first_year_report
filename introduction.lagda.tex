\chapter{Introduction}

\begin{code}[hide]
{-# OPTIONS --cubical --guardedness #-}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.HLevels
open import Cubical.Categories.Category
open import Cubical.Categories.Functor
open import Cubical.Categories.Instances.Sets
open import Cubical.Data.Unit renaming (Unit to ⊤)
open import Cubical.Data.Sum

variable X : Type
\end{code}

\section{Background and Objectives}

Martin-Löf Type Theory (MLTT)\cite{martin1984intuitionistic}\cite{martin1998intuitionistic} provides a constructive foundation for mathematics and programming. The essence of type theory is to represent propositions as types and their proofs as programs\cite{curry1934functionality}. Homotopy Type Theory (HoTT)\cite{program2013homotopy}, a recent developed variant, extends MLTT with ideas from homotopy theory, interpreting types as spaces and equalities as paths. This richer interpretation enables reasoning about higher-dimensional structures, univalence, and equivalences between types.

Within the language of type theory, we study the concepts of containers\cite{abbott2003categories}\cite{abbott2005containers}, which offer a uniform way to represent a range of ``well-behaved'' inductive types. For many data types like trees, list, etc, container provides an alternative way to visualize and reason about their definition and data manipulating. It abstracts a data type into two components: a set of shapes describing the overall form, and within each shape a set of positions telling where data can be stored.

For example, the definition of a list can be visualized as a structure with all finite shapes and, for each shape of length n, there are n many data stored.

\begin{code}
data List (X : Type) : Type where
  s₀ : List X
  s₁ : X → List X
  s₂ : X → X → List X
  s₃ : X → X → X → List X
  {- ... -}
\end{code}

Data transfer can be understood and processed in a similar way. That is to specify the mapping on shapes and positions. For example the tail function on list:

\begin{code}
tail : List X → List X
tail s₀ = s₀
tail (s₁ x) = s₀
tail (s₂ x y) = s₁ y
tail (s₃ x y z) = s₂ y z
{- ... -}
\end{code}

Containers provide a compositional way to define and manipulate data types, making their semantics explicit and supporting generic programming, categorical analysis, and proofs about programs. The unary containers, however, are not capable of capturing data types with higher kinds. For example, the type of the monad transformers\cite{liang1995monad} are not $(Type \to Type)$ but $((Type \to Type) \to Type \to Type)$.

\begin{code}
MaybeT : (Type → Type) → Type → Type
MaybeT M X = M (⊤ ⊎ X)
\end{code}

Despite the higher kinds, $MaybeT$ could still be viewed as type which is specified by shapes and positions of input parameters. Accordingly, our work aims to generalize the containers to a higher-order sense, to provide the semantics for arbitrary higher-order inductive types. More specifically, we wish to:

\begin{itemize}
  \item{define higher functorialities for higher data types}
  \item{provide a syntax for higher containers}
  \item{explore the categorical and algebraic properties of higher containers}
  \item{interpret higher containers to higher functors}
  \item{show that higher containers give rise to a simply typed category with families}
  \item{...}
\end{itemize}

\section{Progress to Date}

Over the first few months, I engaged in a broad exploration of type theory and category theory. I worked on fundational textbooks including \textit{Categories for the Lazy Functional Programmer}\cite{altenkirch2024categories}, \textit{The Tao of Types}\cite{altenkirch2021types}, \textit{Homotopy Type Theory - Univalent Foundations of Mathematics}\cite{program2013homotopy}. I deepened related background knowledge and developed Agda programming skills by formalizing many existing papers. After the training phase, I shifted my focus toward learning and developing my current research area - containers. I met regularly with my supervisor for weekly discussions to track progress, discuss current problems, and plan next steps.

Beside my own research areas, I also learned ongoing research questions and outcomes by actively participating the \textit{Type Theory Cafe} and \textit{Functional Programming Lunch}, which are both internal seminars series within FP Lab. I also gave a talk about my master research - ``Algebraic Effects in Haskell'' on one of the FP Lunch seminars.

I also had many opportunities to attend large-scale academic events. I attended \textit{Midland Graduate School 2025} in Sheffield, where I followed the courses on coalgebras, the Curry-Howard correspondence, refinement type in Haskell. As part of MGS25, I also assisted in teaching a course on category theory by answering questions from the exercise sessions and preparing Latex solutions for the lecture notes. Before MGS25, I participated MGS24 in Leicester and MGS Christmas 24 in Sheffield, where I benefited from many courses and talks. I also attended the \textit{TYPES 2025} in Glasgow, which was a five-day international conference covering a wide range of topics in type theory.

In the spring term, I worked as a teaching assistant for several modules. I helped marking exercises and exams, as well as running weekly tutorials for the module \textit{Languages and Computation}. I also acted as a lab tutor for \textit{Programming Paradigms}, where I supported students on Haskell exercises during weekly lab sessions.

\section{Settings}

We assume the reader is familiar with MLTT and HoTT. Additionally, we presuppose a basic understanding of category theory and do not formally introduce those foundational concepts. 

The formalizations are carried out in Agda\cite{norell2007towards}, which is a dependently typed functional programming language and proof assistant. It enforces features such as strict type checking, termination checking, positivity checking and so on. We also depends on Agda standard libraries \textit{agda-std} and \textit{cubical}. Therefore, for the readability, we employ both Agda code and some standard mathematical notation throughout this report.

The theoretical research is conducted within HoTT, such as interpreting containers as endofunctors on h-level sets. For the sake of formalization, this requires us to explicitly track h-level fields such as \AgdaFunction{isSet} in Cubical Agda, which can be quite bureaucratic and tedious in practice. Instead, to focus on mathematical intuition, we choose to do some post-rigorous math since we are already familiar with how to carry out such constructions rigorously. As such, our formalizations are carried out in plain Agda for intuitionistic purposes.

To be more specific, h-level definitions and checks are omitted. In this case, we are essentially working within a wild category settings. For example, containers and container extension functors are defined in Cubical Agda as:

\begin{code}
record Cont : Type₁ where
  constructor _◃_&_&_
  field
    S : Type
    P : S → Type
    isSetS : isSet S
    isSetP : (s : S) → isSet (P s)

⟦_⟧ : Cont → Functor (SET ℓ-zero) (SET ℓ-zero)
⟦ S ◃ P & isSetS & isSetP ⟧
  = record
  { F-ob = λ (X , isSetX) → 
    (Σ[ s ∈ S ] (P s → X)) , isSetΣ isSetS (λ s → isSet→ isSetX)
  ; F-hom = λ f (s , k) → s , λ p → f (k p)
  ; F-id = λ i (s , k) → s , k
  ; F-seq = λ f g i (s , k) → s , λ p → g (f (k p))
  }
\end{code}

In the plain Agda definition, there would be no fields \AgdaField{isSetS} and \AgdaField{isSetP}. Tto avoid confusion, the primitive Agda \AgdaPrimitive{Set} is renamed to \AgdaPrimitive{Type} to represent small types. Accordingly, bigger types are simply \AgdaPrimitive{Type₁}, \AgdaPrimitive{Type₂}, etc. We also assume function extensionality and minimize the use of universe levels.