\section{Categories with Families}

\begin{code}[hide]
{-# OPTIONS --cubical --guardedness #-}

module scwfs where

open import Cubical.Foundations.Prelude hiding (_,_)

data UU : Set
data EL : UU → Set

data UU where
  con : UU
  ty  : UU
  tms : EL con → EL con → UU
  tm  : EL con → EL ty  → UU

Con : Set
Con = EL con

variable Γ Δ Θ : Con

Ty : Set
Ty = EL ty

variable A B C : Ty

Tms : Con → Con → Set
Tms Δ Γ = EL (tms Δ Γ)

variable γ δ θ : Tms Δ Γ

Tm : Con → Ty → Set
Tm Γ A = EL (tm Γ A)

variable t u : Tm Γ A

infixr 20 _⇒_
infixl 5 _▹_
infixl 5 _,_
infixr 9 _∘_

data EL where
\end{code}

The Categories with Families (CwFs) are categorical framework for interpreting dependent type theory. They model core concepts like context formation, substitution, weakening, etc. However, CwFs are more related to an alternative type theory - a substitution calculus by Martin-Löf, in which the substitution is first class and explicitly formulated.

\subsection{Simply Typed}

We define CwFs as quotient inductive inductive type in Agda. A simply typed Category with families (SCwF) consists of the following:

\begin{itemize}
  \item{a category \texttt{ℂ} of contexts - \texttt{Con : Type} and context substitutions - \texttt{Tms : Con → Con → Set}}
  \begin{code}
    id   : Tms Γ Γ
    _∘_  : Tms Δ Γ → Tms Θ Δ → Tms Θ Γ
    idl  : id ∘ γ ≡ γ
    idr  : γ ∘ id ≡ γ
    ass  : (γ ∘ δ) ∘ θ ≡ γ ∘ (δ ∘ θ)
  \end{code}
  \item{a terminal object - \texttt{∙ : ∣ ℂ ∣} represents the empty substitution}
  \begin{code}
    ∙    : Con
    ε    : Tms Γ ∙
    ∙-η  : γ ≡ ε
  \end{code}
  \item{a set of types - \texttt{Ty : Type}}
  \item{a family of presheaves - \texttt{Tm \_ A : ℂᵒᵖ ⇒ Set} for each \texttt{A : Ty}, which send \texttt{Γ : Con} to \texttt{Tm Γ A : Set}, and \texttt{γ : Tms Δ Γ} to \texttt{\_[ γ ] : Tm Γ A → Tm Δ A}}
  \begin{code}
    _[_] : Tm Γ A → Tms Δ Γ → Tm Δ A
    [id] : t [ id ] ≡ t
    [∘] : t [ γ ∘ δ ] ≡ t [ γ ] [ δ ]
  \end{code}
  \item{a context comprehension operation, which defines context extension and its constraints}
  \begin{code}
    _▹_  : Con → Ty → Con
    _,_  : Tms Δ Γ → Tm Δ A → Tms Δ (Γ ▹ A)
    π₁   : Tms Δ (Γ ▹ A) → Tms Δ Γ
    π₂   : Tms Δ (Γ ▹ A) → Tm Δ A
    π₁β  : π₁ (γ , t) ≡ γ
    π₂β  : π₂ (γ , t) ≡ t
    πη   : π₁ γ , π₂ γ ≡ γ
    ,∘   : (γ , t) ∘ δ ≡ γ ∘ δ , t [ δ ]
  \end{code}
\end{itemize}

\subsection{Adding Functions}

The CwF on its own typically doesn't provide anything about types. We now add function types to the framework.

\begin{code}
    _⇒_  : Ty → Ty → Ty
    lam    : Tm (Γ ▹ A) B → Tm Γ (A ⇒ B)
    app   : Tm Γ (A ⇒ B) → Tm (Γ ▹ A) B
    ⇒β  : app (lam t) ≡ t  
    ⇒η  : lam (app t) ≡ t

    _↑ : Tms Δ Γ → Tms (Δ ▹ A) (Γ ▹ A)
    ↑≡  : γ ↑ ≡ γ ∘ π₁ {A = A} id , π₂ id
    lam[] : lam t [ γ ] ≡ lam (t [ γ ↑ ])
    app[] : app (t [ γ ]) ≡ app t [ γ ↑ ]
\end{code}

With this definition of function type, we can retrieve normal application in \lambda-calculus \texttt{\_\$\_} from \texttt{app} and singleton extension \texttt{<\_>}:

\begin{code}
<_> : Tm Γ A → Tms Γ (Γ ▹ A)
< t > = id , t

_$_ : Tm Γ (A ⇒ B) → Tm Γ A → Tm Γ B
t $ u = app t [ < u > ]
\end{code}
