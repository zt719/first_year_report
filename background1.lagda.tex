\begin{code}[hide]
open import Data.Empty
open import Data.Unit
open import Data.Nat

Type : Set₁
Type = Set

infix  4 _≡_
\end{code}

\section{Our Language}

We adopt Martin-L\"{o}f type theory - MLTT and category theory as the framework for our study. In particular, we use Agda, a programming language which implements MLTT, as our language in this report.

We introduce standard Agda syntax for common algebraic data types :
\begin{itemize}
  \item{\AgdaFunction{⊥} - Empty Type}
  \item{\AgdaRecord{⊤} - Unit Type}
  \item{\AgdaFunction{×} - Product Type}
  \item{\AgdaDatatype{⊎} - Coproduct (Sum) Type}
\end{itemize}

\subsection{Type Theory}

Type theory is a formal language of mathematical logics, designed to serve as a foundation for mathematics and programming languages. Various flavors of type theories exist, differing in their treatment of equality, interpretation of types, computational univalence, etc. We introduce basic concepts in type theory by outlining the development.

\subsubsection*{Simple Type Theory}

Before MLTT, there is simple type theory introduced by Alonzo Church in 1940. It has algebraic types, function types and predicates, where the predicates can quantify over functions and other predicates, which is already in higher-order logics.

\subsubsection*{Universes}

In type theory, everything has a type, even types have a type. We call it the universe and denote it as \AgdaPrimitive{Type}. Such that:

\[ \AgdaFunction{⊥ } \texttt{, } \AgdaRecord{⊤ } \texttt{, } \AgdaDatatype{ℕ } \texttt{... } \AgdaSymbol{: } \AgdaPrimitive{Type} \]

But what is the type of \AgdaPrimitive{Type}? It turns out if we naively postulate \AgdaPrimitive{Type} \AgdaSymbol{:} \AgdaPrimitive{Type}, then it leads to Girard’s paradox which causes inconsistency in the system. The solution is to build hierarchy of the universes:

\[ \AgdaPrimitive{Type } \AgdaSymbol{: } \AgdaPrimitive{Type₁ } \AgdaSymbol{: } \AgdaPrimitive{Type₂ } \AgdaSymbol{: } \texttt{...} \]

where each universe is bigger than the previous ones. In addition, if a type is in a universe, it is also in a bigger universe.

\subsubsection*{MLTT}

Defining type families is straightforward since we already have \AgdaPrimitive{Type}. Type families can be viewed as a generalization of ordinary functions, where the codomain is allowed to be \AgdaPrimitive{Type}. For example a predicates that tells the evenness can be defined as a type family over \AgdaDatatype{ℕ}:

\begin{code}
isEven : ℕ → Type
isEven zero = ⊤
isEven (suc zero) = ⊥
isEven (suc (suc n)) = isEven n
\end{code}

Per Martin-L\"{o}f developed type theory further by adding type family. As a result, we can define type - \AgdaDatatype{Vec} \AgdaBound{n}, where \AgdaBound{n} is the length of the vector. It also generalizes function type \AgdaFunction{→} into dependent function type \AgdaFunction{Π} and pair type \AgdaDatatype{×} into dependent pair type \AgdaDatatype{Σ}.

\subsubsection*{ITT and ETT}

It is important to distinguish different notions of equality. The definitional equality is a very strong notion of equality which two terms are reduced to the same normal forms. However, most theorems and results of practical interests do not hold definitionally. Their proofs normally involves doing case analysis, building extra lemmas, etc. We refer this weaker notion of equality the propositional equality.

In Agda, (definitional) equality is represented by identity type, which is a binary type family over any type \AgdaBound{A}, and it is witnessed by \AgdaInductiveConstructor{refl}.

\begin{code}
data _≡_ {A : Type} (x : A) : A → Type where
  refl : x ≡ x
\end{code}

Therefore, if a proposition is hold directly by \AgdaInductiveConstructor{refl}, then It is definitional equality. In contrast, if an explicit proof is required, then it is propositional equality.

\begin{code}
thm0 : 1 + 1 ≡ 2
thm0 = refl

thm1 : (n : ℕ) → 1 + n ≡ n + 1
thm1 zero = refl
thm1 (suc n) = cong suc (thm1 n)
  where
  cong : {A B : Type} (f : A → B) {x y : A} → x ≡ y → f x ≡ f y
  cong f refl = refl
\end{code}

What is the good notion of equality of functions? Function extensionality suggests that two functions should considered as equal if they yield the same output for every input. However, in intensional type theory, for example Agda, where equality is defined as definitional equality, the \AgdaFunction{funExt} is not provable within the system and must instead be postulated.

\begin{code}
postulate
  funExt : {A : Type} {B : A → Type} {f g : (x : A) → B x} →
           ((x : A) → f x ≡ g x) → f ≡ g
\end{code}

On the other hand, an extensional type theory suggest to treat two notions of equality as the same one. That is, it forces the proposition equality back into the definitional one. However, this approach has significant drawbacks: type checking becomes undecidable, and computation loses canonicity.

\subsubsection*{HoTT}

The homotopy type theory provides a solution to lacking of extensionality in MLTT by adding the univalence axiom. The univalence axiom is It is introduced by Vladimir Voevodsky